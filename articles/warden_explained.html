<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>WARDEN Explained • WARDEN</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="WARDEN Explained">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">WARDEN</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.2.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html" aria-label="View Index"><span class="fa fa-home"></span></a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/warden_explained.html">Warden Explained</a></li>
    <li><a class="dropdown-item" href="../articles/example_ssd.html">Example in a Sick-Sicker-Dead Model</a></li>
    <li><a class="dropdown-item" href="../articles/inputs_selector.html">How to Use the Automatic Input Selector</a></li>
    <li><a class="dropdown-item" href="../articles/example_ssd_stream.html">Example in a Sick-Sicker-Dead Model - Random Number Streams &amp; Luck Adjustment</a></li>
    <li><a class="dropdown-item" href="../articles/example_ssd_sobol.html">Example in a Sick-Sicker-Dead Model - Quasi-Random Sobol Sequence vs. Purely Random</a></li>
    <li><a class="dropdown-item" href="../articles/example_eBC.html">Example in Early Breast Cancer</a></li>
    <li><a class="dropdown-item" href="../articles/example_markov.html">Example in a Markov Model</a></li>
    <li><a class="dropdown-item" href="../articles/example_uncertainty.html">Structural and Parametric Uncertainty</a></li>
    <li><a class="dropdown-item" href="../articles/example_ipd.html">Example for Individual Patient Data</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/jsanchezalv/WARDEN" aria-label="View on Github"><span class="fa fa-github"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>WARDEN Explained</h1>
                        <h4 data-toc-skip class="author">Javier Sanchez
Alvarez</h4>
            
            <h4 data-toc-skip class="date">June 11, 2025</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/jsanchezalv/WARDEN/blob/main/vignettes/articles/warden_explained.Rmd" class="external-link"><code>vignettes/articles/warden_explained.Rmd</code></a></small>
      <div class="d-none name"><code>warden_explained.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This document explains the logic behind WARDEN main approach to
simulate discrete event simulations, as well as explaining briefly the
rationale for certain design decisions.</p>
<div class="section level3">
<h3 id="in-a-nutshell">In a Nutshell<a class="anchor" aria-label="anchor" href="#in-a-nutshell"></a>
</h3>
<p>WARDEN main simulation engine at its core is nothing but a nested
loop at different levels. However, for this to work we need to delay the
execution of the inputs provided by the user, so the relevant inputs
provided through <code>add_tte</code>,
<code>add_item</code>/<code>add_item2</code> and
<code>add_reactevt</code> are substituted for delayed execution and
stored as lists.</p>
<ol style="list-style-type: decimal">
<li>
<strong>Per Analysis (DSA, scenarios) “sens”</strong>
<ol style="list-style-type: decimal">
<li>Load inputs sequentially. If it’s an unnamed list, unlist it and
assign to the “sens” input list.</li>
<li>
<strong>Per Simulation (PSA or deterministic) “simulation”</strong>
<ol style="list-style-type: decimal">
<li>Load inputs sequentially. If it’s an unnamed list, unlist it and
store its components. The “sens” list is integrated into a new list with
the “simulation” input list.</li>
<li>
<strong>Per Patient “i”</strong>
<ol style="list-style-type: decimal">
<li>Load inputs sequentially. If it’s an unnamed list, unlist it and
store its components. The “simulation” list is integrated into a new
list with the “i” input list.</li>
<li>
<strong>Per Arm “arm”</strong>
<ol style="list-style-type: decimal">
<li>Load inputs sequentially. If it’s an unnamed list, unlist it and
store its components. The “i” list is integrated into a new list with
the “arm” input list.</li>
<li>Load initial time to events. First look into the initial time to
event expression declared by user; if not found, look into the input
list already declared; if not found, set equal to <code>Inf</code>.</li>
<li>
<strong>While <code>curtime</code> (simulation time) is &lt;
<code>Inf</code></strong>
<ol style="list-style-type: decimal">
<li>Select the next event by checking the event with minimum time to
event; in case of ties, untie using the order declared in
<code>add_tte</code> for initial time to events. If there are no events
left, set <code>curtime = Inf</code> (end simulation)</li>
<li>Evaluate the reaction of the event by looking at the relevant
expression from the list of event reactions</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Once the specific “simulation” is done, compute outputs vectorized
(discount outcomes as relevant based on their type, aggregate data as
relevant, obtain timed frequency outputs if needed, etc.)</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>The debug mode will store in a log the relevant data that is loaded
or changed by the event reactions, and will be exported when the
simulation stops (also on error). WARDEN allows to continue on error
(though not recommended)</p>
<p>WARDEN handles the random numbers automatically, setting the seeds
differently at the simulation, patient and arm level. WARDEN makes sure
that the starting seed is cloned for a patient across interventions.
However, it could be that conditional statements can alter the random
state of R if they conditional trigger random expressions (e.g.,
<code>if(arm==2){runif(1)}else{5}</code>) that change per intervention.
To keep the random number cloned as intended, it’s recommended to
pre-draw random numbers for each type of random object used and use
those (see the
<code>Example for a Sick-Sicker-Dead model - Random Number Streams &amp; Luck Adjustment</code>
vignette for more information). WARDEN uses L’Ecuyer-CMRG random number
generator.</p>
<p>The way WARDEN processes events through e.g.,
<code>modify_item</code> is by looking at what inputs are currently
available from the relevant input list, evaluating the passed list
(e.g., <code>modify_item_seq(list(a = 1, b = a + 1))</code>) and adding
the resulting objects (<code>a</code> and <code>b</code>) to the parent
environment as well as to the relevant input list for storage. With the
latest update of WARDEN, objects not included in
<code>modify_item</code> will be stored in the relevant input list and
they will be available for evaluation, e.g.,</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">add_reactevt</span>(<span class="at">name_evt =</span> <span class="st">"event_1"</span>, <span class="at">input =</span> {</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  z <span class="ot">&lt;-</span> <span class="dv">2</span> <span class="co">#this will be stored in the main input list, and will be available in the next event reaction! </span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  </span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  <span class="fu">modify_item_seq</span>(<span class="fu">list</span>(<span class="at">a =</span> <span class="dv">1</span>, <span class="at">b =</span> z <span class="sc">+</span> <span class="dv">1</span>, <span class="at">z =</span> z)) <span class="co">#this will work, because z is available</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  </span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>  c <span class="ot">&lt;-</span> b <span class="sc">+</span> <span class="dv">5</span> </span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a>}</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">#The above expression is equivalent to writing:</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="fu">add_reactevt</span>(<span class="at">name_evt =</span> <span class="st">"event_1"</span>, <span class="at">input =</span> {</span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a>  z <span class="ot">&lt;-</span> <span class="dv">2</span> </span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a>  a <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a>  b <span class="ot">&lt;-</span> z <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a>  <span class="fu">modify_item</span>(<span class="fu">list</span>(<span class="at">a =</span> a, <span class="at">b =</span> b, <span class="at">z =</span> z)) </span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a>  </span>
<span id="cb1-18"><a href="#cb1-18" tabindex="-1"></a>  c <span class="ot">&lt;-</span> b <span class="sc">+</span> <span class="dv">5</span> <span class="co">#b will be available </span></span>
<span id="cb1-19"><a href="#cb1-19" tabindex="-1"></a>}</span>
<span id="cb1-20"><a href="#cb1-20" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" tabindex="-1"></a><span class="co">#As well as</span></span>
<span id="cb1-23"><a href="#cb1-23" tabindex="-1"></a><span class="fu">add_reactevt</span>(<span class="at">name_evt =</span> <span class="st">"event_1"</span>, <span class="at">input =</span> {</span>
<span id="cb1-24"><a href="#cb1-24" tabindex="-1"></a>  <span class="fu">modify_item_seq</span>(<span class="fu">list</span>(<span class="at">a =</span> <span class="dv">1</span>, <span class="at">z =</span> <span class="dv">2</span>, <span class="at">b =</span> z <span class="sc">+</span> <span class="dv">1</span>))  <span class="co">#modify_item_seq evaluates sequentially, so the value of z will be available for b</span></span>
<span id="cb1-25"><a href="#cb1-25" tabindex="-1"></a>  </span>
<span id="cb1-26"><a href="#cb1-26" tabindex="-1"></a>    c <span class="ot">&lt;-</span> b <span class="sc">+</span> <span class="dv">5</span> <span class="co">#b will be available </span></span>
<span id="cb1-27"><a href="#cb1-27" tabindex="-1"></a>}</span>
<span id="cb1-28"><a href="#cb1-28" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" tabindex="-1"></a><span class="co">#And</span></span>
<span id="cb1-30"><a href="#cb1-30" tabindex="-1"></a><span class="fu">add_reactevt</span>(<span class="at">name_evt =</span> <span class="st">"event_1"</span>, <span class="at">input =</span> {</span>
<span id="cb1-31"><a href="#cb1-31" tabindex="-1"></a>  a  <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb1-32"><a href="#cb1-32" tabindex="-1"></a>  z  <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb1-33"><a href="#cb1-33" tabindex="-1"></a>  b  <span class="ot">&lt;-</span> z <span class="sc">+</span> <span class="dv">1</span> </span>
<span id="cb1-34"><a href="#cb1-34" tabindex="-1"></a>  c  <span class="ot">&lt;-</span> b <span class="sc">+</span> <span class="dv">5</span> <span class="co">#b will be available </span></span>
<span id="cb1-35"><a href="#cb1-35" tabindex="-1"></a>}</span>
<span id="cb1-36"><a href="#cb1-36" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" tabindex="-1"></a><span class="co">#But note that this will not work!</span></span>
<span id="cb1-38"><a href="#cb1-38" tabindex="-1"></a><span class="fu">add_reactevt</span>(<span class="at">name_evt =</span> <span class="st">"event_1"</span>, <span class="at">input =</span> {</span>
<span id="cb1-39"><a href="#cb1-39" tabindex="-1"></a>  <span class="fu">modify_item</span>(<span class="fu">list</span>(<span class="at">a =</span> <span class="dv">1</span>, <span class="at">z =</span> <span class="dv">2</span>, <span class="at">b =</span> z <span class="sc">+</span> <span class="dv">1</span>))  <span class="co">#modify_item is faster but does not evaluate sequentially (all at once), so the value of z will NOT be available for b</span></span>
<span id="cb1-40"><a href="#cb1-40" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div class="section level3">
<h3 id="storing-inputs-making-it-faster">Storing Inputs, Making it Faster<a class="anchor" aria-label="anchor" href="#storing-inputs-making-it-faster"></a>
</h3>
<p>Multiple ways of storing inputs and processing events can be thought
of. A few of these could be 1) data.frames, 2) lists, 3) environments,
or 4) utilize a C++ implementation (among others). WARDEN uses lists to
store inputs and to process events.</p>
<p>Data.frames can be slow and memory-intense to manipulate, so they
were avoided for this purpose.</p>
<p>Lists and environments can behave quite similar, with environments
being modified by reference, which can speed things up, and it could
give more freedom for the user to declare how to set their event
reactions instead of requiring them to declare <code>modify_item</code>.
However, using environments and more “natural” R expressions (e.g.,
<code>a &lt;- 1; b &lt;- a + 1</code>instead of
<code>modify_item_seq(list(a = 1, b = a + 1))</code>) made the debugging
mode harder to handle. Some internal experiments showed a 20% to 40%
speed increase by switching from lists to environments in the normal
mode. [Changed with WARDEN 1.0] With the most recent update, now the
user does not need to use <code>modify_item</code> or
<code>modify_item_seq</code>, as the transition to environment has been
performed. The limitation with the debugging mode has been handled by
extract the abstract syntax tree of the event reactions and looking for
any type of assignments. A limitation of this is that “dynamic”
assignments (e.g., <code>assign(paste0("x_",i), 5)</code> where
<code>i</code> is created by a loop) are NOT captured by the debugging
engine, and therefore will be excluded from the debugging log file. So
the user should try to assign variables explicitly whenever possible,
e.g., <code>x_1 &lt;- 5</code>.</p>
<p>A C++ implementation was avoided as the purpose of WARDEN is to be
user-friendly and to give the user as much as freedom as possible on how
to define their inputs. While likely much faster, implementation in C++
would require very careful handling of every user input, likely forcing
us to restrict it to very specific data types and functions.</p>
</div>
<div class="section level3">
<h3 id="parallel-engine-approach">Parallel engine approach<a class="anchor" aria-label="anchor" href="#parallel-engine-approach"></a>
</h3>
<p>Furthermore, a parallel core/thread implementation is also available
at the simulation level, i.e., it will perform the “simulation” loop in
parallel. The reason to select the simulation and not the patient is
that each patient normally takes a small amount of time to run, and the
simulation level offers the right balance in terms of time to run.</p>
<p>However, the user should expect it to be only slightly more efficient
(perhaps 20-40% speed increase for medium to large simulations), as
opposed to radically faster. Two factors will be important: the number
of simulations to be run (<code>n_sim</code>), and the size of each
simulation (given by the number of events and the number of patients and
arms). If <code>n_sim</code> is small, it may not be worth it to use a
parallel approach as there is a time loss to set up the different
cores/threads (normally 2 to 5 seconds), so if each simulations runs
fast because they are simple (a couple or seconds or so) it may not be
worth it. Even if <code>n_sim</code> is large and each simulation is
complex, the efficiency gain may be ~20-40%, even if using &gt;5 cores.
The reason is that RAM use increases fast as R creates new sessions with
duplicated data (it’s not shared among the cores/threads), and a medium
to large simulation can easily become &gt;2 GB of RAM use per
simulation, so systems with large processing power AND large RAM (e.g.,
32 or 64GB) will benefit the most from this approach.</p>
<p>The parallel implementation also has limitations in terms of
exporting logs if there is an error in a simulation (due to the parallel
set-up), so this approach is recommended when the user is quite
confident that the simulation will run without issues.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Javier Sanchez Alvarez.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
