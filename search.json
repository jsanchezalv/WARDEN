[{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://jsanchezalv.github.io/RDICE/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example in Early Breast Cancer","text":"document runs discrete event simulation model context early breast cancer show functions can used generate model steps. running DES, ’s important consider speed. Simulation based models can computationally expensive, means using efficient coding can substantial impact performance.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"main-options","dir":"Articles","previous_headings":"Introduction","what":"Main options","title":"Example in Early Breast Cancer","text":"","code":"library(RDICE)  library(purrr) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) library(kableExtra) #>  #> Attaching package: 'kableExtra' #> The following object is masked from 'package:dplyr': #>  #>     group_rows"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"model-concept","dir":"Articles","previous_headings":"Introduction","what":"Model Concept","title":"Example in Early Breast Cancer","text":"Patients start early breast cancer, draw times event. Patients also draw probability going metastatic breast cancer going remission. go remission, can metastatic recurrence. point time can die, depending risk disease stage.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"load-data","dir":"Articles","previous_headings":"Introduction","what":"Load Data","title":"Example in Early Breast Cancer","text":"dummy data costs utility generated .","code":"#Utilities df_util <- data.frame( name = c(\"util.idfs.ontx\" ,\"util.idfs.offtx\" ,\"util.remission\" ,\"util.recurrence\" ,\"util.mbc.progression.mbc\" ,\"util.mbc.pps\"),                          value = c(0.75, 0.8,0.9,0.7,0.6,0.5),                          se=rep(0.02,6),                          stringsAsFactors = FALSE )   #Costs df_cost <- data.frame( name = c(\"cost.idfs.tx\" ,\"cost.recurrence\" ,\"cost.mbc.tx\" ,\"cost.tx.beva\" ,\"cost.idfs.txnoint\",                                   \"cost.idfs\",\"cost.mbc.progression.mbc\",\"cost.mbc.pps\",\"cost.2ndline\",\"cost.ae\"),                          value = c(40000,5000,3000,10000,30000,                                    10000,20000,30000,20000,1000),                          stringsAsFactors = FALSE ) %>%   mutate(se= value/5)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"general-inputs-with-delayed-execution","dir":"Articles","previous_headings":"","what":"General inputs with delayed execution","title":"Example in Early Breast Cancer","text":"Initial inputs flags used model can defined . can define inputs common patients (common_all_inputs) within simulation, inputs unique patient independently treatment (e.g. natural death, defined common_pt_inputs), inputs unique patient treatment (unique_pt_inputs). Items can included add_item function, can used subsequent items (e.g. , define sex_pt use nat.os.s get background mortality patient). inputs generated events reaction events executed. Furthermore, program first executes common_all_inputs, common_pt_inputs unique_pt_inputs. one use items generated common_all_inputs unique_pt_inputs. flag fl.remission drawn using Bernoulli distribution probability 0.8. means 80% patients remission, 20% go early metastatic BC. Note also modeled differently using time remission time early metastatic BC, comparing choosing pathway depending one smaller. also define specific utilities costs used model. create named vector identifies costs utilities, assign specific item. Note util_v cost_v named vector, specific items used model (e.g. util.remission) unnamed. strongly recommended assign unnamed objects going processed model. case, ’re using util_v cost_v intermediate input objects processed (just use make code readable), ’s fine name . However, naming value util.remission (e.g. using one bracket instead two util_v[[\"util.remission\"]]) may cause outputs model change names, depending use. R works: correspond named list named vector/element, R concatenates, case end generating qaly.util.remission output model instead just qaly).","code":"#Each patient is identified through \"i\" #Items used in the model should be unnamed numeric/vectors! otherwise if they are processed by model it can lead to strangely named outcomes #In this case, util_v is a named vector, but it's not processed by the model. We extract unnamed numerics from it.  #Put objects here that do not change on any patient or intervention loop common_all_inputs <- add_item() %>%   add_item( #utilities   pick_val_v(     base =  df_util$value,     psa = MASS::mvrnorm(1,df_util$value,diag(df_util$se^2)),     sens = df_util$value,     psa_ind = psa_bool,     sens_ind = sensitivity_bool,     indicator = rep(0, nrow(df_util)),     names_out =df_util$name   ),#costs   pick_val_v(     base =  df_cost$value,     psa = rgamma_mse(1,df_cost$value,df_cost$se),     sens = df_cost$value,     psa_ind = psa_bool,     sens_ind = sensitivity_bool,     indicator = rep(0, nrow(df_cost)),     names_out =df_cost$name   ) ) #Put objects here that do not change as we loop through interventions for a patient common_pt_inputs <- add_item(sex_pt = ifelse(rbinom(1,1,p=0.01),\"male\",\"female\"),                              nat.os.s = rcond_gompertz(1,                                                      shape=if(sex_pt==\"male\"){0.102}else{0.115},                                                      rate=if(sex_pt==\"male\"){0.000016}else{0.0000041},                                                      lower_bound = 50) ) #in years, for a patient who is 50yo  #Put objects here that change as we loop through treatments for each patient (e.g. events can affect fl.tx, but events do not affect nat.os.s) #common across arm but changes per pt could be implemented here (if (arm==)... ) unique_pt_inputs <- add_item(   fl.idfs.ontx             = 1,   fl.idfs                  = 1,   fl.mbcs.ontx             = 1,   fl.mbcs.progression.mbc  = 1,   fl.tx.beva               = 1,     fl.mbcs                  = 0,   fl.mbcs_2ndline          = 0,   fl.recurrence            = 0,   fl.remission             = rbinom(1,1,0.8), #80% probability of going into remission   q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },   c_default = if(arm==\"noint\"){cost.idfs.txnoint* fl.idfs.ontx  + cost.idfs}else{(cost.idfs.tx) * fl.idfs.ontx + cost.tx.beva * fl.tx.beva + cost.idfs},   c_ae = 0 )"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"add-initial-events","dir":"Articles","previous_headings":"Events","what":"Add Initial Events","title":"Example in Early Breast Cancer","text":"Events added add_tte function. use function twice, one per intervention. must define several arguments: one indicate intervention, one define names events used, one define names objects created like store (optional, maybe generate intermediate input event want save) actual input generate time event. Events objects automatically initialized Inf. draw times event patients. chunk bit complex, ’s worth spending bit time explaining . init_event_list object populated using add_tte function twice, one “int” strategy “noint” strategy. first declare start time 0. proceed generate actual time event. use draw_tte() function generate time event using log-normal distribution event variables interest. One always aware competing risks interact . abstracted type corrections , recommended understanding affect results look competing risks/semi-competing risks literature. Note model, initial list events start, ttot, ttot.beva, progression.mbc, os, idfs, ttot.early, remission, recurrence start.early.mbc. However, , non-initial events can defined reactions part seen section .","code":"init_event_list <-    add_tte(arm=\"int\",                evts = c(\"start\",\"ttot\", \"ttot.beva\",\"progression.mbc\", \"os\",\"idfs\",\"ttot.early\",\"remission\",\"recurrence\",\"start.early.mbc\",\"ae\",\"2ndline_mbc\"),                other_inp = c(\"os.early\",\"os.mbc\"),                input={ #intervention     start <- 0          #Early          idfs <- draw_tte(1,'lnorm',coef1=2, coef2=log(0.2))      ttot.early <- min(draw_tte(1,'lnorm',coef1=2, coef2=log(0.2)),idfs)     ttot.beva <- draw_tte(1,'lnorm',coef1=2, coef2=log(0.2))          os.early <- draw_tte(1,'lnorm',coef1=3, coef2=log(0.2))           #if patient has remission, check when will recurrence happen     if (fl.remission) {        recurrence <- idfs +draw_tte(1,'lnorm',coef1=2, coef2=log(0.2))       remission <- idfs              #if recurrence happens before death       if (min(os.early,nat.os.s)>recurrence) {                   #Late metastatic (after finishing idfs and recurrence)                  os.mbc <- draw_tte(1,'lnorm',coef1=0.8, coef2=log(0.2)) + idfs  +  recurrence                   progression.mbc <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + idfs +  recurrence                   ttot <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + idfs +  recurrence                         }            } else{ #If early metastatic       start.early.mbc <- draw_tte(1,'lnorm',coef1=2.3, coef2=log(0.2))              idfs <- ifelse(start.early.mbc<idfs,start.early.mbc,idfs)       ttot.early <- min(ifelse(start.early.mbc<idfs,start.early.mbc,idfs),ttot.early)              os.mbc <- draw_tte(1,'lnorm',coef1=0.8, coef2=log(0.2)) + start.early.mbc              progression.mbc <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + start.early.mbc              ttot <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + start.early.mbc            }          os <- min(os.mbc,os.early,nat.os.s)         }) %>%  add_tte(arm=\"noint\",                        evts = c(\"start\",\"ttot\", \"ttot.beva\",\"progression.mbc\", \"os\",\"idfs\",\"ttot.early\",\"remission\",\"recurrence\",\"start.early.mbc\"),                        other_inp = c(\"os.early\",\"os.mbc\"),                                               input={  #reference strategy     start <- 0      #Early          idfs <- draw_tte(1,'lnorm',coef1=2, coef2=log(0.2),beta_tx = 1.2)      ttot.early <- min(draw_tte(1,'lnorm',coef1=2, coef2=log(0.2),beta_tx = 1.2),idfs)          os.early <- draw_tte(1,'lnorm',coef1=3, coef2=log(0.2),beta_tx = 1.2)           #if patient has remission, check when will recurrence happen     if (fl.remission) {        recurrence <- idfs +draw_tte(1,'lnorm',coef1=2, coef2=log(0.2))       remission <- idfs              #if recurrence happens before death       if (min(os.early,nat.os.s)>recurrence) {                   #Late metastatic (after finishing idfs and recurrence)                  os.mbc <- draw_tte(1,'lnorm',coef1=0.8, coef2=log(0.2)) + idfs  +  recurrence                   progression.mbc <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + idfs +  recurrence                   ttot <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + idfs +  recurrence                }            } else{ #If early metastatic       start.early.mbc <- draw_tte(1,'lnorm',coef1=2.3, coef2=log(0.2))              idfs <- ifelse(start.early.mbc<idfs,start.early.mbc,idfs)       ttot.early <- min(ifelse(start.early.mbc<idfs,start.early.mbc,idfs),ttot.early)              os.mbc <- draw_tte(1,'lnorm',coef1=0.8, coef2=log(0.2)) + start.early.mbc              progression.mbc <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + start.early.mbc              ttot <- draw_tte(1,'lnorm',coef1=0.5, coef2=log(0.2)) + start.early.mbc                   }         os <- min(os.mbc,os.early,nat.os.s)        })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"add-reaction-to-those-events","dir":"Articles","previous_headings":"Events","what":"Add Reaction to Those Events","title":"Example in Early Breast Cancer","text":"initial times events defined, also need declare events react affect . , use evt_react_list object add_reactevt function. function just needs state event affected, actual reaction (usually setting flags 1 0, creating new/adjusting events). series objects can used context help reactions. Apart global objects flags defined , can also use curtime current event time, prevtime time previous event, cur_evtlist named vector events yet happen patient, arm current treatment loop, evt current event processed, expresses patient iteration, simulation specific simulation (relevant number simulations greater 1). Furthermore, one can also call input/item created create new ones. example, even modify cost/utility item changing directly, e.g. modify_item(list(cost.idfs.tx=500)). functions add/modify events inputs use lists. Whenever several inputs/events added modified, ’s recommended group within one function, reduces computation cost. rather use two modify_item list one element, ’s better group single modify_item list two elements. new_eventallows generate events add vector events. accepts one event. modify_event allows modify events (e.g. delay death). adding event, name events time events must defined. using modify_event, one must indicate events affected new times events. event specified exist already occurred, ignored. modify_event create_if_null = TRUE argument also generate events don’t exist. Note one potentially omit part modeling set init_event_list actually define new events dynamically reactions (\"ae\" event). However, can impact computation time, possible ’s always better use init_event_list. modify_item modify_item_seqallow modify add items. Elements defined within function evaluated sequentially modify_item (.e. defining modify_item(list(fl.new = 1, var1 = fl.new * 5))) give error fl.new defined outside function), modify_item_seq sequentially slightly bigger computational cost, left choices user. Note one can modify costs/utilities using construction type_name_category, type either “qaly” “cost”, name name (e.g., “default”) category category used (e.g., “instant”), one pass cost_default_instant modify cost. list relevant functions used within add_reactevt : model run curtime set Inf, event terminates model (case, os), modify curtime set Inf. Finally, note two different ways accumulating continuous outcomes, backwards (.e., example , set q_default = util.sick sicker event, modify q_default value death event) forwards (example ). option can modified run_sim function using accum_backwards argument, assumes forwards default.","code":"evt_react_list <-   add_reactevt(name_evt = \"start\",                input = {}) %>%   add_reactevt(name_evt = \"ttot\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.mbcs.ontx\"= 0)) #Flag that patient is now off-treatment                                  }) %>%   add_reactevt(name_evt = \"ttot.beva\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default =cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.tx.beva\"= 0)) #Flag that patient is now off-treatment                                  }) %>%   add_reactevt(name_evt = \"progression.mbc\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.mbcs.progression.mbc\"=0,\"fl.mbcs_2ndline\"=1)) #Flag that patient is progressed and going in 2nd line                                    new_event(list(\"2ndline_mbc\" = curtime + draw_tte(1,'exp', log(0.08))/12))                                  }) %>%   add_reactevt(name_evt = \"idfs\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = if(arm==\"noint\"){cost.idfs.txnoint* fl.idfs.ontx  + cost.idfs}else{(cost.idfs.tx) * fl.idfs.ontx + cost.tx.beva * fl.tx.beva + cost.idfs},                               \"fl.idfs\"= 0))                                  }) %>%   add_reactevt(name_evt = \"ttot.early\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = if(arm==\"noint\"){cost.idfs.txnoint* fl.idfs.ontx  + cost.idfs}else{(cost.idfs.tx) * fl.idfs.ontx + cost.tx.beva * fl.tx.beva + cost.idfs},                               \"fl.idfs.ontx\"=0,\"fl.tx.beva\"=0)) #Flag that patient is now off-treatment                                    n_ae <- rpois(1,lambda=0.25*(curtime -prevtime)) #1 AE every 4 years                                    if (n_ae>0) {                    new_event(rep(list(\"ae\" = curtime + 0.0001),n_ae))                  }                }) %>%   add_reactevt(name_evt = \"remission\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.recurrence * fl.recurrence,                               \"fl.remission\"= 1))                                  }) %>%   add_reactevt(name_evt = \"recurrence\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.recurrence * fl.recurrence,                               \"fl.recurrence\"=1,\"fl.remission\"=0,\"fl.mbcs\"=1,\"fl.mbcs.progression.mbc\"=1)) #ad-hoc for plot                                  }) %>%   add_reactevt(name_evt = \"start.early.mbc\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.recurrence * fl.recurrence,                               \"fl.mbcs\"=1,\"fl.mbcs.progression.mbc\"=1))                                  }) %>%   add_reactevt(name_evt = \"2ndline_mbc\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.mbcs_2ndline\"= 0))                                    n_ae <- rpois(1,lambda=0.25*(curtime -prevtime)) #1 AE every 4 years                                    if (n_ae>0) {                    new_event(rep(list(\"ae\" = curtime + 0.0001),n_ae))                  }                }) %>%   add_reactevt(name_evt = \"ae\",                input = {                                                     modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               c_ae = cost.ae))                                    modify_event(list(\"os\" =max(cur_evtlist[[\"os\"]] - 0.125,curtime +0.0001) ))#each AE brings forward death by 1.5 months                }) %>%   add_reactevt(name_evt = \"os\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.tx.beva\"=0,\"fl.mbcs.ontx\"=0,\"fl.idfs\"=0,\"fl.mbcs\"=0,\"curtime\"=Inf))                 })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"costs-and-utilities","dir":"Articles","previous_headings":"","what":"Costs and Utilities","title":"Example in Early Breast Cancer","text":"Costs utilities introduced . However, ’s worth noting model able run without costs utilities. Utilities/Costs/outputs defined declaring object belongs utilities/costs/outputs, whether need discounted continuously discretely (instantaneous). passed run_sim function. ## Utilities","code":"util_ongoing <- \"q_default\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"costs","dir":"Articles","previous_headings":"Costs and Utilities","what":"Costs","title":"Example in Early Breast Cancer","text":"","code":"cost_ongoing <- \"c_default\"  cost_instant <-  \"c_ae\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"model-execution","dir":"Articles","previous_headings":"Model","what":"Model Execution","title":"Example in Early Breast Cancer","text":"model can run using function run_sim . must define number patients simulated, number simulations, whether want run PSA , strategy list, inputs, events reactions defined , utilities, costs also want extra output level ipd data desired exported. worth noting psa_bool argument run PSA automatically, rather additional input/flag model use reference determine whether want use deterministic stochastic input. , also defined common_all_inputs first item defined, result . However, recommend defined run_sim. Note distribution chosen, number events interaction events can substantial impact running time model.","code":"#Logic is: per patient, per intervention, per event, react to that event. results <- run_sim(     npats=2000,                              # number of patients to be simulated   n_sim=1,                                  # number of simulations to run   psa_bool = FALSE,                         # use PSA or not. If n_sim > 1 and psa_bool = FALSE, then difference in outcomes is due to sampling (number of pats simulated)     arm_list = c(\"int\", \"noint\"),             # intervention list   common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation   common_pt_inputs = common_pt_inputs,      # inputs that change within a simulation but are not affected by the intervention   unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions   init_event_list = init_event_list,        # initial event list   evt_react_list = evt_react_list,          # reaction of events   util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   cost_instant_list = cost_instant,   input_out = c(                            # list of additional outputs (Flags, etc) that the user wants to export for each patient and event                 \"os.early\",                 \"os.mbc\",                 \"nat.os.s\",                 \"sex_pt\"                 )           ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 5.11s\" #> [1] \"Time to run analysis 1: 5.11s\" #> [1] \"Total time to run: 5.11s\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"summary-of-results","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Summary of Results","title":"Example in Early Breast Cancer","text":"model run, can use results summarize using summary_results_det print results last simulation (nsim=1, ’s deterministic case), summary_results_sim show PSA results (confidence intervals). can also use individual patient data generated simulation, collect plot psa_ipd object. can also check absolute number events per strategy.","code":"summary_results_det(results[[1]][[1]]) #will print the last simulation! #>                         int      noint #> costs             424345.16  240913.67 #> dcosts                 0.00  183431.49 #> lys                   13.62      12.26 #> dlys                   0.00       1.35 #> qalys                 10.87       9.78 #> dqalys                 0.00       1.09 #> ICER                     NA  135404.15 #> ICUR                     NA  167771.93 #> INMB                     NA -128764.57 #> costs_undisc      485672.92  268770.13 #> dcosts_undisc          0.00  216902.79 #> lys_undisc            17.75      15.43 #> dlys_undisc            0.00       2.32 #> qalys_undisc          14.32      12.40 #> dqalys_undisc          0.00       1.92 #> ICER_undisc              NA   93472.78 #> ICUR_undisc              NA  112871.89 #> INMB_undisc              NA -120819.17 #> c_ae                 468.19     578.50 #> dc_ae                  0.00    -110.30 #> c_ae_undisc          571.00     687.00 #> dc_ae_undisc           0.00    -116.00 #> c_default         423876.96  240335.17 #> dc_default             0.00  183541.79 #> c_default_undisc  485101.92  268083.13 #> dc_default_undisc      0.00  217018.79 #> nat.os.s              34.45      34.45 #> dnat.os.s              0.00       0.00 #> os.early              20.51      17.08 #> dos.early              0.00       3.43 #> os.mbc                21.81      19.54 #> dos.mbc                0.00       2.27 #> q_default             10.87       9.78 #> dq_default             0.00       1.09 #> q_default_undisc      14.32      12.40 #> dq_default_undisc      0.00       1.92  summary_results_sim(results[[1]]) #>                                                int #> costs                   424,345 (424,345; 424,345) #> dcosts                                    0 (0; 0) #> lys                           13.62 (13.62; 13.62) #> dlys                                      0 (0; 0) #> qalys                         10.87 (10.87; 10.87) #> dqalys                                    0 (0; 0) #> ICER                                  NaN (NA; NA) #> ICUR                                  NaN (NA; NA) #> INMB                                  NaN (NA; NA) #> costs_undisc            485,673 (485,673; 485,673) #> dcosts_undisc                             0 (0; 0) #> lys_undisc                    17.75 (17.75; 17.75) #> dlys_undisc                               0 (0; 0) #> qalys_undisc                  14.32 (14.32; 14.32) #> dqalys_undisc                             0 (0; 0) #> ICER_undisc                           NaN (NA; NA) #> ICUR_undisc                           NaN (NA; NA) #> INMB_undisc                           NaN (NA; NA) #> c_ae                       468.19 (468.19; 468.19) #> dc_ae                                     0 (0; 0) #> c_ae_undisc                         571 (571; 571) #> dc_ae_undisc                              0 (0; 0) #> c_default               423,877 (423,877; 423,877) #> dc_default                                0 (0; 0) #> c_default_undisc  485,101.9 (485,101.9; 485,101.9) #> dc_default_undisc                         0 (0; 0) #> nat.os.s                      34.45 (34.45; 34.45) #> dnat.os.s                                 0 (0; 0) #> os.early                      20.51 (20.51; 20.51) #> dos.early                                 0 (0; 0) #> os.mbc                        21.81 (21.81; 21.81) #> dos.mbc                                   0 (0; 0) #> q_default                     10.87 (10.87; 10.87) #> dq_default                                0 (0; 0) #> q_default_undisc              14.32 (14.32; 14.32) #> dq_default_undisc                         0 (0; 0) #>                                              noint #> costs                   240,914 (240,914; 240,914) #> dcosts                  183,431 (183,431; 183,431) #> lys                           12.26 (12.26; 12.26) #> dlys                          1.355 (1.355; 1.355) #> qalys                            9.78 (9.78; 9.78) #> dqalys                        1.093 (1.093; 1.093) #> ICER                    135,404 (135,404; 135,404) #> ICUR                    167,772 (167,772; 167,772) #> INMB                 -128,765 (-128,765; -128,765) #> costs_undisc            268,770 (268,770; 268,770) #> dcosts_undisc           216,903 (216,903; 216,903) #> lys_undisc                    15.43 (15.43; 15.43) #> dlys_undisc                      2.32 (2.32; 2.32) #> qalys_undisc                     12.4 (12.4; 12.4) #> dqalys_undisc                 1.922 (1.922; 1.922) #> ICER_undisc                93,473 (93,473; 93,473) #> ICUR_undisc             112,872 (112,872; 112,872) #> INMB_undisc          -120,819 (-120,819; -120,819) #> c_ae                          578.5 (578.5; 578.5) #> dc_ae                -110.302 (-110.302; -110.302) #> c_ae_undisc                         687 (687; 687) #> dc_ae_undisc                     -116 (-116; -116) #> c_default         240,335.2 (240,335.2; 240,335.2) #> dc_default        183,541.8 (183,541.8; 183,541.8) #> c_default_undisc  268,083.1 (268,083.1; 268,083.1) #> dc_default_undisc 217,018.8 (217,018.8; 217,018.8) #> nat.os.s                      34.45 (34.45; 34.45) #> dnat.os.s                                 0 (0; 0) #> os.early                      17.08 (17.08; 17.08) #> dos.early                     3.432 (3.432; 3.432) #> os.mbc                        19.54 (19.54; 19.54) #> dos.mbc                       2.272 (2.272; 2.272) #> q_default                        9.78 (9.78; 9.78) #> dq_default                    1.093 (1.093; 1.093) #> q_default_undisc                 12.4 (12.4; 12.4) #> dq_default_undisc             1.922 (1.922; 1.922)  psa_ipd <- bind_rows(map(results[[1]], \"merged_df\"))   psa_ipd[1:10,] %>%   kable() %>%   kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_eBC.html","id":"plots","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Plots","title":"Example in Early Breast Cancer","text":"now use data output plot histograms/densities simulation.  can also plot patient level QALY/costs. Note several clusters distribution patients according QALY/costs based pathway took (early metastatic vs. remission cure recurrence).","code":"data_plot <- results[[1]][[1]]$merged_df %>%   filter(evtname != \"start\") %>%   group_by(arm,evtname,simulation) %>%   mutate(median = median(evttime)) %>%   ungroup()  #Density ggplot(data_plot) +   geom_density(aes(fill = arm, x = evttime),                  alpha = 0.7) +   geom_vline(aes(xintercept=median,col=arm)) +   facet_wrap( ~ evtname, scales = \"free_y\") +   scale_y_continuous(expand = c(0, 0)) +   scale_x_continuous(expand = c(0, 0)) +   theme_bw() data_qaly_cost<- psa_ipd[,.SD[1],by=.(pat_id,arm,simulation)][,.(arm,qaly=total_qalys,cost=total_costs,pat_id,simulation)] data_qaly_cost[,ps_id:=paste(pat_id,simulation,sep=\"_\")]   mean_data_qaly_cost <- data_qaly_cost %>% group_by(arm) %>% summarise(across(where(is.numeric),mean))  ggplot(data_qaly_cost,aes(x=qaly, y = cost, col = arm)) +    geom_point(alpha=0.15,shape = 21) +   geom_point(data=mean_data_qaly_cost, aes(x=qaly, y = cost, fill = arm), shape = 21,col=\"black\",size=3) +   scale_y_continuous(expand = c(0, 0)) +   scale_x_continuous(expand = c(0, 0)) +   theme_bw()+   theme(axis.text.x = element_text(angle = 90, vjust = .5))"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example with IPD trial data","text":"document runs discrete event simulation model using simulated individual patient data (IPD) show functions can used generate model IPD trial available.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"packages-and-main-options","dir":"Articles","previous_headings":"","what":"Packages and main options","title":"Example with IPD trial data","text":"","code":"library(RDICE) library(dplyr) library(survival) library(survminer) library(kableExtra) library(tidyr) library(purrr) library(flexsurv) options(scipen = 999) options(tibble.print_max = 50)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"model-concept","dir":"Articles","previous_headings":"","what":"Model concept","title":"Example with IPD trial data","text":"model represented . patients start progression-free state may move progressed state. point time can die, depending risk disease stage. Patients may also experience disease event accelerates progression.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"generate-dummy-ipd-trial-data-and-fit-survival-models","dir":"Articles","previous_headings":"","what":"Generate dummy IPD trial data and fit survival models","title":"Example with IPD trial data","text":"dummy IPD trial data generated using sim_adtte() function flexsurvPlus package. Parametric survival models fit dummy OS TTP IPD. using flexsurv package fit parametric survival models.","code":"#Generate dummy IPD tte.df <- RDICE::tte.df  #Change data frame to wide format tte.df <- tte.df %>% select(-PARAM) %>% pivot_wider(names_from = PARAMCD, values_from = c(AVAL,CNSR))   #Derive Time to Progression Variable from OS and PFS tte.df <- tte.df %>% mutate(   AVAL_TTP = AVAL_PFS,   CNSR_TTP = ifelse(AVAL_PFS == AVAL_OS & CNSR_PFS==0 & CNSR_OS==0,1,CNSR_PFS),   Event_OS = 1-CNSR_OS,   Event_PFS = 1-CNSR_PFS,   Event_TTP = 1-CNSR_TTP   )  #Add baseline characteristics (sex and age) to time to event data IPD <- tte.df %>% mutate(   SEX = rbinom(500,1,0.5),   AGE = rnorm(500,60,8) ) #Plot simulated OS and TTP curves  #Overall survival km.est.OS <- survfit(Surv(AVAL_OS/365.25, Event_OS) ~ ARMCD, data = IPD) #KM curve  OS.fit <- flexsurvreg(formula = Surv(AVAL_OS/365.25, Event_OS) ~ ARMCD, data = IPD, dist = \"Weibull\") #Fit Weibull model to the OS data OS.fit #> Call: #> flexsurvreg(formula = Surv(AVAL_OS/365.25, Event_OS) ~ ARMCD,  #>     data = IPD, dist = \"Weibull\") #>  #> Estimates:  #>         data mean  est     L95%    U95%    se      exp(est)  L95%    U95%   #> shape       NA     1.1346  0.9764  1.3185  0.0870      NA        NA      NA #> scale       NA     3.1523  2.5170  3.9479  0.3620      NA        NA      NA #> ARMCDB  0.5000     0.3066  0.0183  0.5949  0.1471  1.3588    1.0185  1.8129 #>  #> N = 500,  Events: 150,  Censored: 350 #> Total time at risk: 623.0253 #> Log-likelihood = -360.0964, df = 3 #> AIC = 726.1929  ggsurvplot(OS.fit, title=\"Overall survival\",            legend.labs = c(\"Reference\",\"Intervention\"),            risk.table = TRUE) #Time to progression km.est.TTP <- survfit(Surv(AVAL_TTP/365.25, Event_TTP) ~ ARMCD, data = IPD) #KM curve  TTP.fit <- flexsurvreg(formula = Surv(AVAL_TTP/365.25, Event_TTP) ~ ARMCD, data = IPD, dist = \"Weibull\") #Fit Weibull model to the TTP data TTP.fit #> Call: #> flexsurvreg(formula = Surv(AVAL_TTP/365.25, Event_TTP) ~ ARMCD,  #>     data = IPD, dist = \"Weibull\") #>  #> Estimates:  #>         data mean  est     L95%    U95%    se      exp(est)  L95%    U95%   #> shape       NA     1.3757  1.2590  1.5033  0.0622      NA        NA      NA #> scale       NA     0.5865  0.5310  0.6478  0.0297      NA        NA      NA #> ARMCDB  0.5000     1.0992  0.9277  1.2707  0.0875  3.0016    2.5286  3.5632 #>  #> N = 500,  Events: 328,  Censored: 172 #> Total time at risk: 358.9897 #> Log-likelihood = -269.0387, df = 3 #> AIC = 544.0774  ggsurvplot(TTP.fit, title=\"Time to progression\",            legend.labs = c(\"Reference\",\"Intervention\"),            risk.table = TRUE)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"define-des-model-inputs","dir":"Articles","previous_headings":"","what":"Define DES model inputs","title":"Example with IPD trial data","text":"Inputs variables used model defined . can define inputs common patients (common_all_inputs) within simulation, inputs unique patient independently treatment (e.g. natural death, defined common_pt_inputs), inputs unique patient treatment (unique_pt_inputs). Items can included add_item function, can used subsequent items. inputs generated events reaction events executed. Furthermore, program first executes common_all_inputs, common_pt_inputs unique_pt_inputs. one use items generated common_all_inputs unique_pt_inputs.","code":"#Define variables that do not change on any patient or intervention loop common_all_inputs <- add_item(    #Parameters from the survival models   OS.scale = as.numeric(OS.fit$coef[2]),   OS.shape = as.numeric(OS.fit$coef[1]),   OS.coef.int = as.numeric(OS.fit$coef[3]), #Intervention effect    TTP.scale = as.numeric(TTP.fit$coef[2]),   TTP.shape = as.numeric(TTP.fit$coef[1]),   TTP.coef.int = as.numeric(TTP.fit$coef[3]), #Intervention effect      #Utilities   util.PFS = 0.6, #Utility while in progression-free state   util.PPS = 0.4, #Utility while in progressed state   disutil.PAE = -0.02, #One-off disutility of progression-accelerating event    #Costs   cost.drug.int = 85000, #Annual intervention cost   cost.drug.ref = 29000, #Annual cost of reference treatment   cost.admin.SC = 150, #Unit cost for each SC administration   cost.admin.oral = 300, #One-off cost for oral administration   cost.dm.PFS = 3000, #Annual disease-management cost in progression-free state   cost.dm.PPS = 5000, #Annual disease-management cost in progressed state   cost.ae.int = 2200, #Annual adverse event costs for intervention   cost.ae.ref = 1400 #Annual adverse event costs for reference treatment     )   #Define variables that do not change as we loop through interventions for a patient common_pt_inputs <- add_item(   #Patient baseline characteristics   Sex = as.numeric(IPD[i,\"SEX\"]), #Record sex of individual patient. 0 = Female; 1 =Male   BLAge = as.numeric(IPD[i,\"AGE\"]), #Record patient age at baseline      #Draw time to non-disease related death from a conditional Gompertz distribution   nat.death = rcond_gompertz(1,shape=if(Sex==1){0.102}else{0.115},                                rate=if(Sex==1){0.000016}else{0.0000041},                                lower_bound = BLAge) # Baseline Age in years   )   #Define variables that change as we loop through treatments for each patient. unique_pt_inputs <- add_item(   fl.int  = 0, #Flag to determine if patient is on intervention. Initialized as 0, but will be changed to current arm in the Start event.   fl.prog = 0, #Flag to determine if patient has progressed. All patients start progression-free   fl.ontx = 1, #Flag to determine if patient is on treatment. All patients start on treatment   fl.PAE = 0,  #Flag to determine if progression-accelerating event occurred   pfs.time = NA, #Recording of time at progression   q_default = ifelse(fl.prog == 0, util.PFS, util.PPS),   q_default_inst = 0,   c_default = ifelse(fl.prog == 0,cost.dm.PFS,cost.dm.PPS) + if(arm==\"int\"){(cost.drug.int + cost.admin.SC * 12 + cost.ae.int) * fl.ontx}else{cost.drug.ref + cost.ae.ref},   c_default_inst = 0 )"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"add-initial-events","dir":"Articles","previous_headings":"Events","what":"Add Initial Events","title":"Example with IPD trial data","text":"define now possible events can occur intervention reference arm respectively using add_tte() function. patients intervention arm can treatment discontinuation, patients arms can progression, progression-accelerating death event. seed argument used draw_tte() function uses item ensure event times specific patient can replicated updated later time points.","code":"init_event_list <-    #Events applicable to intervention   add_tte(arm=c(\"int\",\"ref\"),           evts = c(\"Start\",                    \"TxDisc\",                    \"Progression\",                    \"PAE\",                    \"Death\"),                input={     Start <- 0     Progression <- draw_tte(1,'weibull',coef1=TTP.shape, coef2= TTP.scale + ifelse(arm==\"int\",TTP.coef.int,0),seed = as.numeric(paste0(1,i,simulation)))     TxDisc <- Inf #Treatment discontinuation will occur at progression     Death <- min(draw_tte(1,'weibull',coef1=OS.shape, coef2= OS.scale + ifelse(arm==\"int\",OS.coef.int,0), seed = as.numeric(paste0(42,i,simulation))), nat.death) #Death occurs at earliest of disease-related death or non-disease-related death     PAE <- draw_tte(1,'exp',coef1=-log(1-ifelse(arm==\"int\",0.05,0.15))) #Occurrence of the progression-accelerating event has a 5% or 15% probability for the intervention arm   })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"add-event-reactions","dir":"Articles","previous_headings":"Events","what":"Add Event Reactions","title":"Example with IPD trial data","text":"Reactions individual event defined following using add_reactevt() function. Patients intervention arm discontinue treatment progression. Occurrence progression-accelerated event results earlier progression (occurred yet). Note use seed argument draw_tte() function ensures seed used original updated draw time progression.","code":"evt_react_list <-   add_reactevt(name_evt = \"Start\",                input = {                  modify_item(list(fl.int = ifelse(arm==\"int\",1,0),                                   q_default = ifelse(fl.prog == 0, util.PFS, util.PPS),                                   c_default = ifelse(fl.prog == 0,cost.dm.PFS,cost.dm.PPS) + if(arm==\"int\"){(cost.drug.int + cost.admin.SC * 12 + cost.ae.int) * fl.ontx}else{cost.drug.ref + cost.ae.ref},                                   c_default_inst = cost.admin.oral                                   ))                }) %>%   add_reactevt(name_evt = \"TxDisc\",                input = {                  modify_item(list(q_default = ifelse(fl.prog == 0, util.PFS, util.PPS),                                   c_default = ifelse(fl.prog == 0,cost.dm.PFS,cost.dm.PPS) + if(arm==\"int\"){(cost.drug.int + cost.admin.SC * 12 + cost.ae.int) * fl.ontx}else{cost.drug.ref + cost.ae.ref},                                   \"fl.ontx\"= 0))                }) %>%   add_reactevt(name_evt = \"Progression\",                input = {                  modify_item(list(q_default = ifelse(fl.prog == 0, util.PFS, util.PPS),                                   c_default = ifelse(fl.prog == 0,cost.dm.PFS,cost.dm.PPS) + if(arm==\"int\"){(cost.drug.int + cost.admin.SC * 12 + cost.ae.int) * fl.ontx}else{cost.drug.ref + cost.ae.ref},                                   \"pfs.time\"=curtime,\"fl.prog\"= 1))                  if(arm==\"int\"){modify_event(list(\"TxDisc\" = curtime))} #Trigger treatment discontinuation at progression                }) %>%   add_reactevt(name_evt = \"Death\",                input = {                  modify_item(list(q_default = ifelse(fl.prog == 0, util.PFS, util.PPS),                                   c_default = ifelse(fl.prog == 0,cost.dm.PFS,cost.dm.PPS) + if(arm==\"int\"){(cost.drug.int + cost.admin.SC * 12 + cost.ae.int) * fl.ontx}else{cost.drug.ref + cost.ae.ref},                                   \"curtime\"=Inf))                 }) %>%   add_reactevt(name_evt = \"PAE\",                input = {                  modify_item(list(\"fl.PAE\"= 1,                                   q_default = ifelse(fl.prog == 0, util.PFS, util.PPS),                                   q_default_inst = disutil.PAE,                                   c_default = ifelse(fl.prog == 0,cost.dm.PFS,cost.dm.PPS) + if(arm==\"int\"){(cost.drug.int + cost.admin.SC * 12 + cost.ae.int) * fl.ontx}else{cost.drug.ref + cost.ae.ref}))                                    if(fl.prog == 0){ #Event only accelerates progression if progression has not occurred yet                  modify_event(list(                    \"Progression\"=max(draw_tte(1,'weibull',coef1=TTP.shape, coef2= TTP.scale + TTP.coef.int*fl.int, beta_tx = 1.2, seed = as.numeric(paste0(1,i,simulation))),curtime))) #Occurrence of event accelerates progression by a factor of 1.2                  }                })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"costs-and-utilities","dir":"Articles","previous_headings":"","what":"Costs and Utilities","title":"Example with IPD trial data","text":"Costs utilities introduced .","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"utilities","dir":"Articles","previous_headings":"Costs and Utilities","what":"Utilities","title":"Example with IPD trial data","text":"","code":"util_ongoing <- \"q_default\"  util_instant <- \"q_default_inst\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"costs","dir":"Articles","previous_headings":"Costs and Utilities","what":"Costs","title":"Example with IPD trial data","text":"","code":"cost_ongoing <- \"c_default\"  cost_instant <- \"c_default_inst\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"model-execution","dir":"Articles","previous_headings":"Model","what":"Model Execution","title":"Example with IPD trial data","text":"model executed event reactions inputs previously defined patient simulated data set.","code":"#Logic is: per patient, per intervention, per event, react to that event. results <- run_sim(     npats=as.numeric(nrow(IPD)),              # Simulating the number of patients for which we have IPD   n_sim=1,                                  # We run all patients once (per treatment)   psa_bool = FALSE,                         # No PSA for this example   arm_list = c(\"int\", \"ref\"),                common_all_inputs = common_all_inputs,       common_pt_inputs = common_pt_inputs,         unique_pt_inputs = unique_pt_inputs,         init_event_list = init_event_list,           evt_react_list = evt_react_list,             util_ongoing_list = util_ongoing,   util_instant_list = util_instant,   cost_ongoing_list = cost_ongoing,   cost_instant_list = cost_instant,   input_out = c(\"BLAge\",\"Sex\",\"nat.death\",\"pfs.time\") ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.91s\" #> [1] \"Time to run analysis 1: 0.91s\" #> [1] \"Total time to run: 0.92s\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"summary-of-results","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Summary of Results","title":"Example with IPD trial data","text":"model run, can use results summarize using summary_results_det print results deterministic case. individual patient data generated simulation recorded psa_ipd object. can also check absolute number events per strategy.","code":"summary_results_det(results[[1]][[1]]) #will print the last simulation! #>                              int        ref #> costs                  261251.76   94361.19 #> dcosts                      0.00  166890.57 #> lys                         3.60       2.75 #> dlys                        0.00       0.85 #> qalys                       1.71       1.41 #> dqalys                      0.00       0.30 #> ICER                          NA  195784.55 #> ICUR                          NA  563768.08 #> INMB                          NA -152089.22 #> costs_undisc           286099.08  101986.36 #> dcosts_undisc               0.00  184112.72 #> lys_undisc                  3.99       2.97 #> dlys_undisc                 0.00       1.02 #> qalys_undisc                1.88       1.52 #> dqalys_undisc               0.00       0.35 #> ICER_undisc                   NA  180232.81 #> ICUR_undisc                   NA  518666.81 #> INMB_undisc                   NA -166364.07 #> BLAge                      59.66      59.66 #> dBLAge                      0.00       0.00 #> c_default              260951.76   94061.19 #> dc_default                  0.00  166890.57 #> c_default_inst            300.00     300.00 #> dc_default_inst             0.00       0.00 #> c_default_inst_undisc     300.00     300.00 #> dc_default_inst_undisc      0.00       0.00 #> c_default_undisc       285799.08  101686.36 #> dc_default_undisc           0.00  184112.72 #> nat.death                  24.33      24.33 #> dnat.death                  0.00       0.00 #> pfs.time                    1.61       0.58 #> dpfs.time                   0.00       1.03 #> q_default                   1.73       1.43 #> dq_default                  0.00       0.30 #> q_default_inst             -0.02      -0.02 #> dq_default_inst             0.00       0.00 #> q_default_inst_undisc      -0.02      -0.02 #> dq_default_inst_undisc      0.00       0.00 #> q_default_undisc            1.89       1.54 #> dq_default_undisc           0.00       0.36 #> Sex                         0.53       0.53 #> dSex                        0.00       0.00  psa_ipd <- bind_rows(map(results[[1]], \"merged_df\"))   psa_ipd[1:10,] %>%   kable() %>%   kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ipd.html","id":"plots","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Plots","title":"Example with IPD trial data","text":"now use simulation output plot Kaplan-Meier curves simulated OS PFS observed Kaplan-Meier curves. simulated progression-free survival curve lower observed due addition progression-accelerating event model.","code":"#Overall survival KM.death <- psa_ipd %>% filter(evtname==\"Death\") %>% mutate(Event = 1)  sim.km.OS <- survfit(Surv(evttime, Event) ~ arm, data = KM.death)  km.comb <- list(   Observed = km.est.OS,   Predicted = sim.km.OS )  ggsurvplot(km.comb, combine = TRUE,            title=\"Overall Survival\",            palette=c(\"coral\",\"turquoise\",\"turquoise3\",\"coral3\"),            legend.labs=c(\"Observed - Ref\",\"Observed - Int\",\"Predicted - Int\",\"Predicted - Ref\"),            linetype = c(2,2,1,1),            xlim=c(0,10), break.time.by = 1, censor=FALSE) #Progression-free survival km.est.PFS <- survfit(Surv(AVAL_PFS/365.25, Event_PFS) ~ ARMCD, data = IPD) KM.PFS.DES <- psa_ipd %>% filter(evtname==\"Death\") %>% mutate(evttime = ifelse(is.na(pfs.time),evttime,pfs.time),                                                           Event = 1)  sim.km.PFS <- survfit(Surv(evttime, Event) ~ arm, data = KM.PFS.DES)  km.comb <- list(Observed = km.est.PFS,                 Predicted = sim.km.PFS)  ggsurvplot(km.comb,combine = TRUE,            title=\"Progression-free Survival\",            palette=c(\"coral\",\"turquoise\",\"turquoise3\",\"coral3\"),            legend.labs=c(\"Observed - Ref\",\"Observed - Int\",\"Predicted - Int\",\"Predicted - Ref\"),            linetype = c(2,2,1,1),            xlim=c(0,5), break.time.by = 1, censor = FALSE)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example for a Markov Model","text":"document runs discrete event simulation model context simple cohort Markov model 4 states. Note exercise done patient simulation approach (microsimulation) rather cohort one.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"main-options","dir":"Articles","previous_headings":"Introduction","what":"Main options","title":"Example for a Markov Model","text":"","code":"library(RDICE)  library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) library(kableExtra) #>  #> Attaching package: 'kableExtra' #> The following object is masked from 'package:dplyr': #>  #>     group_rows library(purrr)  #Show all numbers, no scientific notation options(scipen = 999)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"model-concept","dir":"Articles","previous_headings":"Introduction","what":"Model Concept","title":"Example for a Markov Model","text":"model simple Markov model 4 states whose transition matrix can found . order run pure Markov model within functions, define event cycle. generate initial trace event (cycle) update trace multiplying transition matrix. Costs QALYs can computed similar fashion multiplying trace times cost utility.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"load-data","dir":"Articles","previous_headings":"Introduction","what":"Load Data","title":"Example for a Markov Model","text":"dummy data generated . data structure defined , otherwise give problems.","code":"#Utilities util.data <- data.frame( name = c(\"util1\" ,\"util2\" ,\"util3\" ,\"util4\"),                          value = c(0.9,0.75,0.6,0),                          se=rep(0.02,4),                          stringsAsFactors = FALSE )   #Costs cost.data <- data.frame( name = c(\"cost1\" ,\"cost2\" ,\"cost3\" ,\"cost4\",\"cost_int\"),                          value = c(1000,3000,6000,0,1000),                          stringsAsFactors = FALSE ) %>%   mutate(se= value/5)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"general-inputs-with-delayed-execution","dir":"Articles","previous_headings":"","what":"General inputs with delayed execution","title":"Example for a Markov Model","text":"Initial inputs flags used model can defined . can define inputs common patients (common_all_inputs) within simulation, inputs unique patient independently treatment (e.g. natural death, defined common_pt_inputs), inputs unique patient treatment (unique_pt_inputs). Items can included add_item function, can used subsequent items. inputs generated events reaction events executed. Furthermore, program first executes common_all_inputs, common_pt_inputs unique_pt_inputs. one use items generated common_all_inputs unique_pt_inputs. also define specific utilities costs used model. strongly recommended assign unnamed objects going processed model. case, ’re using util_v cost_v intermediate input objects processed (just use make code readable), ’s fine name . define initial trace, number cycles simulated, transition matrices initial cycle time (.e. 0). important note QALYs Costs used length 1. length > 1, model expand data, instead event row, event 4 rows (1 per state). means processing results data needed order provide correct results.","code":"#Put objects here that do not change on any patient or intervention loop, for example costs and utilities common_all_inputs <- add_item(max_n_cycles = 30) %>%   add_item( #utilities      pick_val_v(base        = util.data$value,                 psa         = pick_psa(rep(\"rbeta_mse\",nrow(util.data)),rep(1,nrow(util.data)),util.data$value,util.data$se),                 sens        = util.data$value,                 psa_ind     = psa_bool,                 sens_ind    = sensitivity_bool,                 indicator   = rep(0, nrow(util.data)),                 names_out   = util.data[,\"name\"]                 )      ) %>%   add_item( #costs     pick_val_v(base         = cost.data$value,                 psa         = pick_psa(rep(\"rgamma_mse\",nrow(cost.data)),rep(1,nrow(cost.data)),cost.data$value,cost.data$se),                 sens        = cost.data$value,                 psa_ind     = psa_bool,                 sens_ind    = sensitivity_bool,                 indicator   = rep(0, nrow(cost.data)),                 names_out   = cost.data[,\"name\"]                 )     )   #Put objects here that change as we loop through treatments for each patient (e.g. events can affect fl.tx, but events do not affect nat.os.s) #common across arm but changes per pt could be implemented here (if (arm==)... ) unique_pt_inputs <- add_item(                             trace = c(1,0,0,0), #initialize trace, everyone at state 1                             transition = if( arm==\"noint\"){                                              matrix(c(0.4,0.3,0.2,0.1,                                             0.1,0.4,0.3,0.2,                                             0.1,0.1,0.5,0.3,                                             0,0,0,1),nrow=4,byrow=T)                                          } else{                                             matrix(c(0.5,0.3,0.1,0.1,                                                      0.2,0.4,0.3,0.1,                                                      0.1,0.2,0.5,0.2,                                                      0,0,0,1),nrow=4,byrow=T)                                               }, # In this case we have two different matrices, note this could also be a single matrix using symbolic RRs or similar                                                          #Alternative approach                             # rr = ifelse(arm==\"noint\",1,0.9),                             # transition_2 = matrix(c(0.4,0.3,0.2,0.1,                             #                 0.1,0.4,0.3,0.2,                             #                 0.1,0.1,0.5,0.3,                             #                 0,0,0,1),nrow=4,byrow=T) * rr,                             # transition_2 = cbind(1-rowSums(transition_2[,-1]),transition_2[,-1]) ,                             cycle_time = 0,                             q_default =  trace %*% c(util1,util2,util3,util4), #utilities weighted by state to get QALY                             c_default = if(arm==\"noint\"){                                trace %*% c(cost1+ cost_int,cost2+ cost_int,cost3+ cost_int,cost4)                              } else{                                trace %*% c(cost1,cost2,cost3,cost4)                              } )"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"add-initial-events","dir":"Articles","previous_headings":"Events","what":"Add Initial Events","title":"Example for a Markov Model","text":"model, events start cycle.","code":"init_event_list <-    add_tte(arm=c(\"noint\",\"int\"),evts=c(\"start\",\"cycle\"),input={ #intervention     start <- 0     cycle <- 1        })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"add-reaction-to-those-events","dir":"Articles","previous_headings":"Events","what":"Add Reaction to Those Events","title":"Example for a Markov Model","text":"explanation part works can seen models. Markov model case, event start generate many cycles need. cycle event update time cycle keep track produce output model update trace. Finally, events , finish simulation setting curtime infinity. Alternatively, just use start event iterate cycle, saving everything array. alternative option described involve tweaking running model (using time dimension, e.g., discounting assuming previous time 0 current time 0 instead vector times, results require post-processing adequate).","code":"evt_react_list <-   add_reactevt(name_evt = \"start\",                input = {                  for (i in 2:max_n_cycles) {                    new_event(list(\"cycle\" = curtime + i))                  }                                  }) %>%   add_reactevt(name_evt = \"cycle\",                input = {                   modify_item_seq(list(                    q_default = trace %*% c(util1,util2,util3,util4),                    c_default = if(arm==\"noint\"){                                  trace %*% c(cost1+ cost_int,cost2+ cost_int,cost3+ cost_int,cost4)                                } else{                                  trace %*% c(cost1,cost2,cost3,cost4)                                },                    cycle_time = cycle_time + 1,                    trace = trace %*% transition #or transition_2                    ))                                     if (max_n_cycles == cycle_time) {                    modify_item(list(curtime = Inf)) #Indicate end of simulation for patient                  }                })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"costs-and-utilities","dir":"Articles","previous_headings":"","what":"Costs and Utilities","title":"Example for a Markov Model","text":"Costs utilities introduced . However, ’s worth noting model able run without costs utilities.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"utilities","dir":"Articles","previous_headings":"Costs and Utilities","what":"Utilities","title":"Example for a Markov Model","text":"","code":"util_ongoing <- \"q_default\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"costs","dir":"Articles","previous_headings":"Costs and Utilities","what":"Costs","title":"Example for a Markov Model","text":"","code":"cost_ongoing <- \"c_default\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"model-execution","dir":"Articles","previous_headings":"Model","what":"Model Execution","title":"Example for a Markov Model","text":"model can run using function run_sim . must define number patients simulated, number simulations, whether want run PSA , strategy list, inputs, events reactions defined , utilities, costs also want extra output level ipd data desired exported. worth noting psa_bool argument run PSA automatically, rather additional input/flag model use reference determine whether want use deterministic stochastic input. , also defined common_all_inputs first item defined, result . However, recommend defined run_sim. Note distribution chosen, number events interaction events can substantial impact running time model. Since taking cohort approach, just need indicate npats = 1.","code":"#Logic is: per patient, per intervention, per event, react to that event. results <- run_sim(     npats=1,                               # number of patients, recommended to set to 1000 if using PSA as it takes quite a while   n_sim=1,                                  # if >1, then PSA, otherwise deterministic   psa_bool = FALSE,   arm_list = c(\"int\", \"noint\"),             # intervention list   common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation   unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions   init_event_list = init_event_list,        # initial event list   evt_react_list = evt_react_list,          # reaction of events   util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   input_out = c(                            # list of additional outputs (Flags, etc) that the user wants to export for each patient and event     \"trace\",     \"cycle_time\"   ) ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.07s\" #> [1] \"Time to run analysis 1: 0.07s\" #> [1] \"Total time to run: 0.08s\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"summary-of-results","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Summary of Results","title":"Example for a Markov Model","text":"model run, can use results summarize using summary_results_det print results last simulation (nsim=1, ’s deterministic case), summary_results_sim show PSA results (confidence intervals). can also use individual patient data generated simulation, collect psa_ipd object. Note data life years wrong, model assumes running patient simulation data therefore ’s adding 4 states together, inflating total life years. can manually adjust get correct life years. Note trace data exported separately ’s length > 1. can also check cycles","code":"summary_results_det(results[[1]][[1]]) #will print the last simulation! #>                        int     noint #> costs             18957.73  20353.56 #> dcosts                0.00  -1395.83 #> lys                  19.89     19.89 #> dlys                  0.00      0.00 #> qalys                 5.81      4.37 #> dqalys                0.00      1.44 #> ICER                    NA      -Inf #> ICUR                    NA   -971.07 #> INMB                    NA  73266.50 #> costs_undisc      23836.54  23677.54 #> dcosts_undisc         0.00    159.00 #> lys_undisc           30.00     30.00 #> dlys_undisc           0.00      0.00 #> qalys_undisc          6.92      4.90 #> dqalys_undisc         0.00      2.02 #> ICER_undisc             NA       Inf #> ICUR_undisc             NA     78.75 #> INMB_undisc             NA 100797.64 #> c_default         18957.73  20353.56 #> dc_default            0.00  -1395.83 #> c_default_undisc  23836.54  23677.54 #> dc_default_undisc     0.00    159.00 #> cycle_time           30.00     30.00 #> dcycle_time           0.00      0.00 #> q_default             5.81      4.37 #> dq_default            0.00      1.44 #> q_default_undisc      6.92      4.90 #> dq_default_undisc     0.00      2.02  psa_ipd <- bind_rows(map(results[[1]], \"merged_df\"))  traces <- data.table::rbindlist(results[[1]][[1]]$extradata_raw)  trace_t <- cbind(traces,  psa_ipd[rep(seq(1, nrow(psa_ipd)), each = 4)]) %>%   mutate(state = rep(seq(1:4),62))  trace_t[1:10,] %>%   kable() %>%   kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\")) life_years <-  trace_t  %>%    group_by(arm) %>%   filter(state!=4) %>% #erase death state for LY computation   mutate(ly_final = lys*lag(trace,3L)) %>% #multiply by previous trace summarise(ly_final = sum(ly_final,na.rm = TRUE)) #get final discounted life years  life_years %>%   kable() %>%   kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\")) results[[1]][[1]][[\"total_lys\"]][[\"int\"]] <- life_years$ly_final[life_years$arm==\"int\"] results[[1]][[1]][[\"total_lys\"]][[\"noint\"]] <- life_years$ly_final[life_years$arm==\"noint\"]  summary_results_det(results[[1]][[1]]) #will print the last simulation! #>                        int     noint #> costs             18957.73  20353.56 #> dcosts                0.00  -1395.83 #> lys                   6.31      4.53 #> dlys                  0.00      1.78 #> qalys                 5.81      4.37 #> dqalys                0.00      1.44 #> ICER                    NA   -785.61 #> ICUR                    NA   -971.07 #> INMB                    NA  73266.50 #> costs_undisc      23836.54  23677.54 #> dcosts_undisc         0.00    159.00 #> lys_undisc           30.00     30.00 #> dlys_undisc           0.00      0.00 #> qalys_undisc          6.92      4.90 #> dqalys_undisc         0.00      2.02 #> ICER_undisc             NA       Inf #> ICUR_undisc             NA     78.75 #> INMB_undisc             NA 100797.64 #> c_default         18957.73  20353.56 #> dc_default            0.00  -1395.83 #> c_default_undisc  23836.54  23677.54 #> dc_default_undisc     0.00    159.00 #> cycle_time           30.00     30.00 #> dcycle_time           0.00      0.00 #> q_default             5.81      4.37 #> dq_default            0.00      1.44 #> q_default_undisc      6.92      4.90 #> dq_default_undisc     0.00      2.02"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_markov.html","id":"plots","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Plots","title":"Example for a Markov Model","text":"now use data plot traces.","code":"ggplot(trace_t,aes(x=evttime,y = trace,col=arm)) + geom_line() + facet_wrap(~state)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example for a Sick-Sicker-Dead model","text":"document runs discrete event simulation model context late oncology model show functions can used generate model steps. running DES, ’s important consider speed. Simulation based models can computationally expensive, means using efficient coding can substantial impact performance.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"main-options","dir":"Articles","previous_headings":"Introduction","what":"Main options","title":"Example for a Sick-Sicker-Dead model","text":"","code":"library(RDICE)  library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) library(kableExtra) #>  #> Attaching package: 'kableExtra' #> The following object is masked from 'package:dplyr': #>  #>     group_rows library(purrr) options(scipen = 999) options(digits=3) options(tibble.print_max = 50)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"general-inputs-with-delayed-execution","dir":"Articles","previous_headings":"","what":"General inputs with delayed execution","title":"Example for a Sick-Sicker-Dead model","text":"Initial inputs flags used model can defined . can define inputs change across scenarios (sensitivity_inputs), inputs common patients (common_all_inputs) within simulation, inputs unique patient independently treatment (e.g. natural time death, defined common_pt_inputs), inputs unique patient treatment (unique_pt_inputs). Items can included add_item function, can used subsequent items. inputs generated events reaction events executed. Furthermore, program first executes common_all_inputs, common_pt_inputs unique_pt_inputs. one use items generated common_all_inputs unique_pt_inputs. Note inputs “reset” patient, patient 1 arm “noint” changes util.sick = 2, even ’s common parameter everyone, reset 1 patient 1 arm “int”. Note time death set common_pt_inputs, also just set add_tte function explained . user full flexibility implement type inputs. auxiliary functions help setting inputs, like pick_val_v pick_val (pick_psa, see section Sensitivity Analysis). Note pick_val_v pick_val can directly loaded parameters (fact, named list loaded directly R). small tweak needed ’s first item added, item list must initiated using add_item() (see ).","code":"#We don't need to use sensitivity_inputs here, so we don't add that object  #Put objects here that do not change on any patient or intervention loop common_all_inputs <-add_item(                       util.sick = 0.8,                       util.sicker = 0.5,                       cost.sick = 3000,                       cost.sicker = 7000,                       cost.int = 1000,                       coef_noint = log(0.2),                       HR_int = 0.8,                       drc = 0.035, #different values than what's assumed by default                       drq = 0.035,                       random_seed_sicker_i = sample.int(100000,1000,replace = FALSE))  #to be used as seeds to draw the time to event for sicker, to ensure same luck for the same patient independently of the arm   #Put objects here that do not change as we loop through treatments for a patient common_pt_inputs <- add_item(death= max(0.0000001,rnorm(n=1, mean=12, sd=3)))   #Put objects here that change as we loop through treatments for each patient (e.g. events can affect fl.tx, but events do not affect nat.os.s) unique_pt_inputs <- add_item(fl.sick = 1,                              q_default = util.sick,                              c_default = cost.sick + if(arm==\"int\"){cost.int}else{0})"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"add-initial-events","dir":"Articles","previous_headings":"Events","what":"Add Initial Events","title":"Example for a Sick-Sicker-Dead model","text":"Events added add_tte function. use function applying interventions. must define several arguments: one indicate intervention, one define names events used, one define names objects created like store (optional, maybe generate intermediate input event want save) actual input generate time event. Events objects automatically initialized Inf. draw times event patients. Note: order evts argument appears first used reference order process events case ties (“sick” processed “sicker” tie time event.) Note model use evnets defined evts argument look objects defined input list expression allocate time events. event declared evts defined elsewhere, assumed TTE Inf default. chunk bit complex, ’s worth spending bit time explaining . init_event_list object populated using add_tte function applies arms, “int” strategy “noint” strategy. first declare start time 0. Note also separated arm user wants clarity using two add_tte functions (.e., add_tte(arm=\"noint\"...) %>% add_tte(arm=\"int\"...)). proceed generate actual time event. use draw_tte() function generate time event, though one can set way (e.g., using rexp). One always aware competing risks interact . abstracted type corrections , recommended understanding affect results look competing risks/semi-competing risks literature.","code":"init_event_list <-    add_tte(arm=c(\"noint\",\"int\"), evts = c(\"sick\",\"sicker\",\"death\") ,input={     sick <- 0     sicker <- draw_tte(1,dist=\"exp\", coef1=coef_noint, beta_tx = ifelse(arm==\"int\",HR_int,1), seed = random_seed_sicker_i[i]) #this way the value would be the same if it wasn't for the HR, effectively \"cloning\" patients luck        })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"add-reaction-to-those-events","dir":"Articles","previous_headings":"Events","what":"Add Reaction to Those Events","title":"Example for a Sick-Sicker-Dead model","text":"initial times events defined, also need declare events react affect . , use evt_react_list object add_reactevt function. function just needs state event affected, actual reaction (usually setting flags 1 0, creating new/adjusting events). series objects can used context help reactions. Apart global objects flags defined , can also use curtime current event time, prevtime time previous event, cur_evtlist named vector events yet happen patient, arm current treatment loop, evt current event processed, expresses patient iteration, simulation specific simulation (relevant number simulations greater 1). Furthermore, one can also call input/item created create new ones. example, even modify cost/utility item changing directly, e.g. modify_item(list(cost.idfs.tx=500)). functions add/modify events inputs use lists. Whenever several inputs/events added modified, ’s recommended group within one function, reduces computation cost. rather use two modify_item list one element, ’s better group single modify_item list two elements. new_eventallows generate events add vector events. accepts one event. modify_event allows modify events (e.g. delay death). adding event, name events time events must defined. using modify_event, one must indicate events affected new times events. event specified exist already occurred, ignored. modify_event create_if_null = TRUE argument also generate events don’t exist. Note one potentially omit part modeling set init_event_list actually define new events dynamically reactions (\"ae\" event). However, can impact computation time, possible ’s always better use init_event_list. modify_item modify_item_seqallow modify add items. Elements defined within function evaluated sequentially modify_item (.e. defining modify_item(list(fl.new = 1, var1 = fl.new * 5))) give error fl.new defined outside function), modify_item_seq sequentially slightly bigger computational cost, left choices user. Note one can modify costs/utilities using construction type_name_category, type either “qaly” “cost”, name name (e.g., “default”) category category used (e.g., “instant”), one pass cost_default_instant modify cost. list relevant functions used within add_reactevt : model run curtime set Inf, event terminates model (case, os), modify curtime set Inf. Finally, note two different ways accumulating continuous outcomes, backwards (.e., example , set q_default = util.sick sicker event, modify q_default value death event) forwards (example ). option can modified run_sim function using accum_backwards argument, assumes forwards default. can also now use extract_from_reactions function obtain data.frame relationships defined reactions model. functions looks modify_item, modify_item_seq, modify_event new_event checks elements defined , definition, whether triggered conditionally (e.g., \"(==1){modify_item(list(b=2))}\"). Note straightforward build network graph showcasing interactions events terms events affecting events, show () events affect specific items.","code":"evt_react_list <-   add_reactevt(name_evt = \"sick\",                input = {}) %>%   add_reactevt(name_evt = \"sicker\",                input = {                  modify_item(list(q_default = util.sicker,                                   c_default = cost.sicker + if(arm==\"int\"){cost.int}else{0},                                   fl.sick = 0))                 }) %>%   add_reactevt(name_evt = \"death\",                input = {                  modify_item(list(q_default = 0,                                   c_default = 0,                                    curtime = Inf))                 }) df_interactions <- extract_from_reactions(evt_react_list)  kable(df_interactions)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"costs-and-utilities","dir":"Articles","previous_headings":"","what":"Costs and Utilities","title":"Example for a Sick-Sicker-Dead model","text":"Costs utilities introduced . However, ’s worth noting model able run without costs utilities. Utilities/Costs/outputs defined declaring object belongs utilities/costs/outputs, whether need discounted continuously discretely (instantaneous). passed run_sim function.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"utilities","dir":"Articles","previous_headings":"Costs and Utilities","what":"Utilities","title":"Example for a Sick-Sicker-Dead model","text":"","code":"util_ongoing <- \"q_default\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"costs","dir":"Articles","previous_headings":"Costs and Utilities","what":"Costs","title":"Example for a Sick-Sicker-Dead model","text":"","code":"cost_ongoing <- \"c_default\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"model-execution","dir":"Articles","previous_headings":"Model","what":"Model Execution","title":"Example for a Sick-Sicker-Dead model","text":"model can run using function run_sim . must define number patients simulated, number simulations, whether want run PSA , strategy list, inputs, events reactions defined , utilities, costs also want extra output level ipd data desired exported. worth noting psa_bool argument run PSA automatically, rather additional input/flag model use reference determine whether want use deterministic stochastic input. , also defined common_all_inputs first item defined, result . However, recommend defined run_sim. Note distribution chosen, number events interaction events can substantial impact running time model. Debugging can implemented using argument debug run_sim function.","code":"#Logic is: per patient, per intervention, per event, react to that event. results <- run_sim(     npats=1000,                               # number of patients to be simulated   n_sim=1,                                  # number of simulations to run   psa_bool = FALSE,                         # use PSA or not. If n_sim > 1 and psa_bool = FALSE, then difference in outcomes is due to sampling (number of pats simulated)     arm_list = c(\"int\", \"noint\"),             # intervention list   common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation   common_pt_inputs = common_pt_inputs,      # inputs that change within a simulation but are not affected by the intervention   unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions   init_event_list = init_event_list,        # initial event list   evt_react_list = evt_react_list,          # reaction of events   util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   ipd = 1 ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.85s\" #> [1] \"Time to run analysis 1: 0.85s\" #> [1] \"Total time to run: 0.85s\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"summary-of-results","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Summary of Results","title":"Example for a Sick-Sicker-Dead model","text":"model run, can use results summarize using summary_results_det print results last simulation (nsim = 1, ’s deterministic case), summary_results_sim show PSA results (confidence intervals). can also use individual patient data generated simulation, collect plot psa_ipd object. can also check absolute number events per strategy.","code":"summary_results_det(results[[1]][[1]]) #print first simulation #>                        int    noint #> costs             58978.88 51768.23 #> dcosts                0.00  7210.66 #> lys                   9.72     9.72 #> dlys                  0.00     0.00 #> qalys                 6.27     6.08 #> dqalys                0.00     0.19 #> ICER                    NA      Inf #> ICUR                    NA 38286.46 #> INMB                    NA  2206.06 #> costs_undisc      74324.03 65474.81 #> dcosts_undisc         0.00  8849.22 #> lys_undisc           11.99    11.99 #> dlys_undisc           0.00     0.00 #> qalys_undisc          7.62     7.38 #> dqalys_undisc         0.00     0.24 #> ICER_undisc             NA      Inf #> ICUR_undisc             NA 37557.56 #> INMB_undisc             NA  2931.65 #> c_default         58978.88 51768.23 #> dc_default            0.00  7210.66 #> c_default_undisc  74324.03 65474.81 #> dc_default_undisc     0.00  8849.22 #> q_default             6.27     6.08 #> dq_default            0.00     0.19 #> q_default_undisc      7.62     7.38 #> dq_default_undisc     0.00     0.24  summary_results_sim(results[[1]]) #>                                       int                   noint #> costs             58,979 (58,979; 58,979) 51,768 (51,768; 51,768) #> dcosts                           0 (0; 0)    7,211 (7,211; 7,211) #> lys                     9.72 (9.72; 9.72)       9.72 (9.72; 9.72) #> dlys                             0 (0; 0)                0 (0; 0) #> qalys                   6.27 (6.27; 6.27)       6.08 (6.08; 6.08) #> dqalys                           0 (0; 0)    0.188 (0.188; 0.188) #> ICER                         NaN (NA; NA)          Inf (Inf; Inf) #> ICUR                         NaN (NA; NA) 38,286 (38,286; 38,286) #> INMB                         NaN (NA; NA)    2,206 (2,206; 2,206) #> costs_undisc      74,324 (74,324; 74,324) 65,475 (65,475; 65,475) #> dcosts_undisc                    0 (0; 0)    8,849 (8,849; 8,849) #> lys_undisc                    12 (12; 12)             12 (12; 12) #> dlys_undisc                      0 (0; 0)                0 (0; 0) #> qalys_undisc            7.62 (7.62; 7.62)       7.38 (7.38; 7.38) #> dqalys_undisc                    0 (0; 0)    0.236 (0.236; 0.236) #> ICER_undisc                  NaN (NA; NA)          Inf (Inf; Inf) #> ICUR_undisc                  NaN (NA; NA) 37,558 (37,558; 37,558) #> INMB_undisc                  NaN (NA; NA)    2,932 (2,932; 2,932) #> c_default         58,979 (58,979; 58,979) 51,768 (51,768; 51,768) #> dc_default                       0 (0; 0)    7,211 (7,211; 7,211) #> c_default_undisc  74,324 (74,324; 74,324) 65,475 (65,475; 65,475) #> dc_default_undisc                0 (0; 0)    8,849 (8,849; 8,849) #> q_default               6.27 (6.27; 6.27)       6.08 (6.08; 6.08) #> dq_default                       0 (0; 0)    0.188 (0.188; 0.188) #> q_default_undisc        7.62 (7.62; 7.62)       7.38 (7.38; 7.38) #> dq_default_undisc                0 (0; 0)    0.236 (0.236; 0.236)  summary_results_sens(results) #>        arm analysis analysis_name          variable                   value #>     <char>    <int>        <char>            <fctr>                  <char> #>  1:    int        1                           costs 58,979 (58,979; 58,979) #>  2:  noint        1                           costs 51,768 (51,768; 51,768) #>  3:    int        1                          dcosts                0 (0; 0) #>  4:  noint        1                          dcosts    7,211 (7,211; 7,211) #>  5:    int        1                             lys       9.72 (9.72; 9.72) #>  6:  noint        1                             lys       9.72 (9.72; 9.72) #>  7:    int        1                            dlys                0 (0; 0) #>  8:  noint        1                            dlys                0 (0; 0) #>  9:    int        1                           qalys       6.27 (6.27; 6.27) #> 10:  noint        1                           qalys       6.08 (6.08; 6.08) #> 11:    int        1                          dqalys                0 (0; 0) #> 12:  noint        1                          dqalys    0.188 (0.188; 0.188) #> 13:    int        1                            ICER            NaN (NA; NA) #> 14:  noint        1                            ICER          Inf (Inf; Inf) #> 15:    int        1                            ICUR            NaN (NA; NA) #> 16:  noint        1                            ICUR 38,286 (38,286; 38,286) #> 17:    int        1                            INMB            NaN (NA; NA) #> 18:  noint        1                            INMB    2,206 (2,206; 2,206) #> 19:    int        1                    costs_undisc 74,324 (74,324; 74,324) #> 20:  noint        1                    costs_undisc 65,475 (65,475; 65,475) #> 21:    int        1                   dcosts_undisc                0 (0; 0) #> 22:  noint        1                   dcosts_undisc    8,849 (8,849; 8,849) #> 23:    int        1                      lys_undisc             12 (12; 12) #> 24:  noint        1                      lys_undisc             12 (12; 12) #> 25:    int        1                     dlys_undisc                0 (0; 0) #> 26:  noint        1                     dlys_undisc                0 (0; 0) #> 27:    int        1                    qalys_undisc       7.62 (7.62; 7.62) #> 28:  noint        1                    qalys_undisc       7.38 (7.38; 7.38) #> 29:    int        1                   dqalys_undisc                0 (0; 0) #> 30:  noint        1                   dqalys_undisc    0.236 (0.236; 0.236) #> 31:    int        1                     ICER_undisc            NaN (NA; NA) #> 32:  noint        1                     ICER_undisc          Inf (Inf; Inf) #> 33:    int        1                     ICUR_undisc            NaN (NA; NA) #> 34:  noint        1                     ICUR_undisc 37,558 (37,558; 37,558) #> 35:    int        1                     INMB_undisc            NaN (NA; NA) #> 36:  noint        1                     INMB_undisc    2,932 (2,932; 2,932) #> 37:    int        1                       c_default 58,979 (58,979; 58,979) #> 38:  noint        1                       c_default 51,768 (51,768; 51,768) #> 39:    int        1                      dc_default                0 (0; 0) #> 40:  noint        1                      dc_default    7,211 (7,211; 7,211) #> 41:    int        1                c_default_undisc 74,324 (74,324; 74,324) #> 42:  noint        1                c_default_undisc 65,475 (65,475; 65,475) #> 43:    int        1               dc_default_undisc                0 (0; 0) #> 44:  noint        1               dc_default_undisc    8,849 (8,849; 8,849) #> 45:    int        1                       q_default       6.27 (6.27; 6.27) #> 46:  noint        1                       q_default       6.08 (6.08; 6.08) #> 47:    int        1                      dq_default                0 (0; 0) #> 48:  noint        1                      dq_default    0.188 (0.188; 0.188) #> 49:    int        1                q_default_undisc       7.62 (7.62; 7.62) #> 50:  noint        1                q_default_undisc       7.38 (7.38; 7.38) #> 51:    int        1               dq_default_undisc                0 (0; 0) #> 52:  noint        1               dq_default_undisc    0.236 (0.236; 0.236) #>        arm analysis analysis_name          variable                   value  psa_ipd <- bind_rows(map(results[[1]], \"merged_df\"))   psa_ipd[1:10,] %>%   kable() %>%   kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"plots","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Plots","title":"Example for a Sick-Sicker-Dead model","text":"now use data output plot histograms/densities simulation.  can also plot patient level incremental QALY/costs.","code":"data_plot <- results[[1]][[1]]$merged_df %>%   filter(evtname != \"sick\") %>%   group_by(arm,evtname,simulation) %>%   mutate(median = median(evttime)) %>%   ungroup()  ggplot(data_plot) +   geom_density(aes(fill = arm, x = evttime),                alpha = 0.7) +   geom_vline(aes(xintercept=median,col=arm)) +   facet_wrap( ~ evtname, scales = \"free\") +   scale_y_continuous(expand = c(0, 0)) +   scale_x_continuous(expand = c(0, 0)) +   theme_bw() data_qaly_cost<- psa_ipd[,.SD[1],by=.(pat_id,arm,simulation)][,.(arm,qaly=total_qalys,cost=total_costs,pat_id,simulation)] data_qaly_cost[,ps_id:=paste(pat_id,simulation,sep=\"_\")]   mean_data_qaly_cost <- data_qaly_cost %>% group_by(arm) %>% summarise(across(where(is.numeric),mean))  ggplot(data_qaly_cost,aes(x=qaly, y = cost, col = arm)) +    geom_point(alpha=0.15,shape = 21) +   geom_point(data=mean_data_qaly_cost, aes(x=qaly, y = cost, fill = arm), shape = 21,col=\"black\",size=3) +   scale_y_continuous(expand = c(0, 0)) +   scale_x_continuous(expand = c(0, 0)) +   theme_bw()+   theme(axis.text.x = element_text(angle = 90, vjust = .5))"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"inputs","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Inputs","title":"Example for a Sick-Sicker-Dead model","text":"case, inputs must created first change across sensitivity analysis. , item list sensitivity_inputs can used. case, also use pick_val_v allows model automatically pick relevant value (PSA, PSA sensitivity analysis) based corresponding boolean flags psa_bool sensitivity_bool. case also use sens iterator sensitivity analysis n_sensitivity argument run_sim. Note just changed inputs handled common_all_inputs, done unique_pt_inputs, cases, inputs change per patient, pick_val_v pick_val functions applied within unique_pt_inputs make sure evaluated correspond. Note psa directly calling distributions passing parameters.Note also sens_name_used automatically computed engine accesible user (’s name sensitivity analysis, e.g., “scenario 1”). indicator parameter pick_val_v pick_val used determine parameters left “” ones substituted sensitivity value. two ways , either setting binary way (1 0), using indicator number parameter values varied (useful several parameters varied time, specific values vector varied). can set using indicator_sens_binary argument. Note pick_val_v pick_val can directly loaded parameters (fact, named list loaded directly R). small tweak needed ’s first item added, item list must initiated using add_item() (see ). Note one can use list lists case base_value parameters vectors instead elements length 1. case, showcase list also use data.frame. pick_psa can used select correct PSA distributions.","code":"#Load some data list_par <- list(parameter_name = list(\"util.sick\",\"util.sicker\",\"cost.sick\",\"cost.sicker\",\"cost.int\",\"coef_noint\",\"HR_int\"),                               base_value = list(0.8,0.5,3000,7000,1000,log(0.2),0.8),                               DSA_min = list(0.6,0.3,1000,5000,800,log(0.1),0.5),                               DSA_max = list(0.9,0.7,5000,9000,2000,log(0.4),0.9),                               PSA_dist = list(\"rnorm\",\"rbeta_mse\",\"rgamma_mse\",\"rgamma_mse\",\"rgamma_mse\",\"rnorm\",\"rlnorm\"),                               a=list(0.8,0.5,3000,7000,1000,log(0.2),0.8),                               b=lapply(list(0.8,0.5,3000,7000,1000,log(0.2),0.8), function(x) abs(x/5)),                               scenario_1=list(0.6,0.3,1000,5000,800,log(0.1),0.5),                               scenario_2=list(0.9,0.7,5000,9000,2000,log(0.4),0.9)                               )  sensitivity_inputs <-add_item(             indicators = if(sensitivity_bool){ create_indicators(sens,n_sensitivity*length(sensitivity_names),rep(1,length(list_par[[1]])))}else{                                 rep(1,length(list_par[[1]]))} #vector of indicators, value 0 everywhere except at sens, where it takes value 1 (for dsa_min and dsa_max, if not sensitivity analysis, then we activate all of them, i.e., in a PSA)                               )  common_all_inputs <-add_item() %>%    add_item(             pick_val_v(base        = list_par[[\"base_value\"]],                        psa         = pick_psa(list_par[[\"PSA_dist\"]],rep(1,length(list_par[[\"PSA_dist\"]])),list_par[[\"a\"]],list_par[[\"b\"]]),                        sens        = list_par[[sens_name_used]],                        psa_ind     = psa_bool,                        sens_ind    = sensitivity_bool,                        indicator   = indicators,                        names_out   = list_par[[\"parameter_name\"]]                        )             ) %>%   add_item(random_seed_sicker_i = sample(1:1000,1000,replace = FALSE)) #we don't add this variable ot the sensitivity analysis"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"model-execution-1","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Model Execution","title":"Example for a Sick-Sicker-Dead model","text":"model executed , just adding sensitivity_inputs, sensitivity_names, sensitivity_bool n_sensitivity arguments. Note total number sensitivity iterations given n_sensitivity, n_sensitivity * length(sensitivity_names), case 2 x n_sensitivity, 2 x 7 = 14. two scenario analysis 2 x 1 = 2, indicators variable defined previous section taking value 1 variables altered scenario, 0 otherwise.","code":"results <- run_sim(     npats=100,                               # number of patients to be simulated   n_sim=1,                                  # number of simulations to run   psa_bool = FALSE,                         # use PSA or not. If n_sim > 1 and psa_bool = FALSE, then difference in outcomes is due to sampling (number of pats simulated)     arm_list = c(\"int\", \"noint\"),             # intervention list   common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation   common_pt_inputs = common_pt_inputs,      # inputs that change within a simulation but are not affected by the intervention   unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions   init_event_list = init_event_list,        # initial event list   evt_react_list = evt_react_list,          # reaction of events   util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   sensitivity_inputs = sensitivity_inputs,   sensitivity_names = c(\"DSA_min\",\"DSA_max\"),   sensitivity_bool = TRUE,   n_sensitivity = length(list_par[[1]]),   input_out = unlist(list_par[[\"parameter_name\"]]) ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.16s\" #> [1] \"Time to run analysis 1: 0.16s\" #> [1] \"Analysis number: 2\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 2: 0.17s\" #> [1] \"Analysis number: 3\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.16s\" #> [1] \"Time to run analysis 3: 0.16s\" #> [1] \"Analysis number: 4\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 4: 0.17s\" #> [1] \"Analysis number: 5\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 5: 0.17s\" #> [1] \"Analysis number: 6\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 6: 0.17s\" #> [1] \"Analysis number: 7\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 7: 0.17s\" #> [1] \"Analysis number: 8\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 8: 0.17s\" #> [1] \"Analysis number: 9\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 9: 0.17s\" #> [1] \"Analysis number: 10\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 10: 0.17s\" #> [1] \"Analysis number: 11\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 11: 0.17s\" #> [1] \"Analysis number: 12\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.21s\" #> [1] \"Time to run analysis 12: 0.21s\" #> [1] \"Analysis number: 13\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 13: 0.17s\" #> [1] \"Analysis number: 14\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Time to run analysis 14: 0.18s\" #> [1] \"Total time to run: 2.4s\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"check-results","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Check results","title":"Example for a Sick-Sicker-Dead model","text":"briefly check indeed engine changing corresponding parameter value.","code":"data_sensitivity <- bind_rows(map_depth(results,2, \"merged_df\"))  #Check mean value across iterations as PSA is off data_sensitivity %>% group_by(sensitivity) %>% summarise_at(c(\"util.sick\",\"util.sicker\",\"cost.sick\",\"cost.sicker\",\"cost.int\",\"coef_noint\",\"HR_int\"),mean) #> # A tibble: 14 × 8 #>    sensitivity util.sick util.sicker cost.sick cost.sicker cost.int coef_noint #>          <int>     <dbl>       <dbl>     <dbl>       <dbl>    <dbl>      <dbl> #>  1           1       0.6         0.5      3000        7000     1000      -1.61 #>  2           2       0.8         0.3      3000        7000     1000      -1.61 #>  3           3       0.8         0.5      1000        7000     1000      -1.61 #>  4           4       0.8         0.5      3000        5000     1000      -1.61 #>  5           5       0.8         0.5      3000        7000      800      -1.61 #>  6           6       0.8         0.5      3000        7000     1000      -2.30 #>  7           7       0.8         0.5      3000        7000     1000      -1.61 #>  8           8       0.8         0.5      3000        7000     1000      -1.61 #>  9           9       0.8         0.5      3000        7000     1000      -1.61 #> 10          10       0.8         0.5      3000        7000     1000      -1.61 #> 11          11       0.8         0.5      3000        7000     1000      -1.61 #> 12          12       0.8         0.5      3000        7000     1000      -1.61 #> 13          13       0.8         0.5      3000        7000     1000      -1.61 #> 14          14       0.8         0.5      3000        7000     1000      -1.61 #> # ℹ 1 more variable: HR_int <dbl>"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"model-execution-probabilistic-dsa","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Model Execution, probabilistic DSA","title":"Example for a Sick-Sicker-Dead model","text":"model executed , just activating psa_bool option","code":"results <- run_sim(     npats=100,                                  n_sim=6,                                     psa_bool = TRUE,                            arm_list = c(\"int\", \"noint\"),                common_all_inputs = common_all_inputs,       common_pt_inputs = common_pt_inputs,         unique_pt_inputs = unique_pt_inputs,         init_event_list = init_event_list,           evt_react_list = evt_react_list,             util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   sensitivity_inputs = sensitivity_inputs,   sensitivity_names = c(\"DSA_min\",\"DSA_max\"),   sensitivity_bool = TRUE,   n_sensitivity = length(list_par[[1]]),   input_out = unlist(list_par[[\"parameter_name\"]]) ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 1: 1.05s\" #> [1] \"Analysis number: 2\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.34s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.16s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 2: 1.18s\" #> [1] \"Analysis number: 3\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.16s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.16s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.16s\" #> [1] \"Time to run analysis 3: 1s\" #> [1] \"Analysis number: 4\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.16s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.16s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.16s\" #> [1] \"Time to run analysis 4: 1.01s\" #> [1] \"Analysis number: 5\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.16s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 5: 1.03s\" #> [1] \"Analysis number: 6\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.16s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.16s\" #> [1] \"Time to run analysis 6: 1s\" #> [1] \"Analysis number: 7\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.16s\" #> [1] \"Time to run analysis 7: 1.03s\" #> [1] \"Analysis number: 8\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.2s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 8: 1.08s\" #> [1] \"Analysis number: 9\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 9: 1.08s\" #> [1] \"Analysis number: 10\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 10: 1.06s\" #> [1] \"Analysis number: 11\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.19s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 11: 1.07s\" #> [1] \"Analysis number: 12\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 12: 1.08s\" #> [1] \"Analysis number: 13\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.2s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.19s\" #> [1] \"Time to run analysis 13: 1.1s\" #> [1] \"Analysis number: 14\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.35s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.16s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 14: 1.19s\" #> [1] \"Total time to run: 14.96s\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"check-results-1","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Check results","title":"Example for a Sick-Sicker-Dead model","text":"briefly check indeed engine changing corresponding parameter value.","code":"data_sensitivity <- bind_rows(map_depth(results,2, \"merged_df\"))  #Check mean value across iterations as PSA is off data_sensitivity %>% group_by(sensitivity) %>% summarise_at(c(\"util.sick\",\"util.sicker\",\"cost.sick\",\"cost.sicker\",\"cost.int\",\"coef_noint\",\"HR_int\"),mean) #> # A tibble: 14 × 8 #>    sensitivity util.sick util.sicker cost.sick cost.sicker cost.int coef_noint #>          <int>     <dbl>       <dbl>     <dbl>       <dbl>    <dbl>      <dbl> #>  1           1     0.6         0.579     3150.       7969.    1064.      -1.62 #>  2           2     0.723       0.3       3150.       7969.    1064.      -1.62 #>  3           3     0.723       0.579     1000        7969.    1064.      -1.62 #>  4           4     0.723       0.579     3150.       5000     1064.      -1.62 #>  5           5     0.723       0.579     3150.       7969.     800       -1.62 #>  6           6     0.724       0.579     3143.       7962.    1065.      -2.30 #>  7           7     0.722       0.580     3155.       7973.    1061.      -1.62 #>  8           8     0.723       0.579     3150.       7969.    1064.      -1.62 #>  9           9     0.723       0.579     3150.       7969.    1064.      -1.62 #> 10          10     0.723       0.579     3150.       7969.    1064.      -1.62 #> 11          11     0.723       0.579     3150.       7969.    1064.      -1.62 #> 12          12     0.723       0.579     3150.       7969.    1064.      -1.62 #> 13          13     0.723       0.579     3150.       7969.    1064.      -1.62 #> 14          14     0.723       0.579     3150.       7969.    1064.      -1.62 #> # ℹ 1 more variable: HR_int <dbl>"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"model-execution-simple-psa","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Model Execution, Simple PSA","title":"Example for a Sick-Sicker-Dead model","text":"model executed , just activating psa_bool option deactivating sensitivity_bool removing sensitivity_names setting n_sensitivity = 1","code":"results <- run_sim(     npats=100,                                  n_sim=10,                                     psa_bool = TRUE,                            arm_list = c(\"int\", \"noint\"),                common_all_inputs = common_all_inputs,       common_pt_inputs = common_pt_inputs,         unique_pt_inputs = unique_pt_inputs,         init_event_list = init_event_list,           evt_react_list = evt_react_list,             util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   sensitivity_inputs = sensitivity_inputs,   sensitivity_bool = FALSE,   n_sensitivity = 1,   input_out = unlist(list_par[[\"parameter_name\"]]) ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Simulation number: 7\" #> [1] \"Time to run simulation 7: 0.17s\" #> [1] \"Simulation number: 8\" #> [1] \"Time to run simulation 8: 0.17s\" #> [1] \"Simulation number: 9\" #> [1] \"Time to run simulation 9: 0.17s\" #> [1] \"Simulation number: 10\" #> [1] \"Time to run simulation 10: 0.17s\" #> [1] \"Time to run analysis 1: 1.72s\" #> [1] \"Total time to run: 1.72s\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd.html","id":"check-results-2","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Check results","title":"Example for a Sick-Sicker-Dead model","text":"briefly check indeed engine changing corresponding parameter values.","code":"data_simulation <- bind_rows(map_depth(results,2, \"merged_df\"))  #Check mean value across iterations as PSA is off data_simulation %>% group_by(simulation) %>% summarise_at(c(\"util.sick\",\"util.sicker\",\"cost.sick\",\"cost.sicker\",\"cost.int\",\"coef_noint\",\"HR_int\"),mean) #> # A tibble: 10 × 8 #>    simulation util.sick util.sicker cost.sick cost.sicker cost.int coef_noint #>         <int>     <dbl>       <dbl>     <dbl>       <dbl>    <dbl>      <dbl> #>  1          1     0.528       0.563     5010.       9352.    1073.      -1.43 #>  2          2     0.666       0.544     3065.       7914.     808.      -1.07 #>  3          3     0.742       0.526     2393.       7690.    1323.      -1.99 #>  4          4     0.727       0.767     2491.       8069.    1009.      -1.34 #>  5          5     0.808       0.570     4021.       7834.    1026.      -1.93 #>  6          6     0.874       0.501     1881.       6913.    1158.      -2.01 #>  7          7     0.859       0.457     2730.       9349.    1264.      -1.70 #>  8          8     0.935       0.438     3954.       6225.     813.      -1.35 #>  9          9     0.886       0.648     3104.       7909.     695.      -1.75 #> 10         10     0.870       0.576     3952.       6264.    1176.      -1.52 #> # ℹ 1 more variable: HR_int <dbl>"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"document runs discrete event simulation model context late oncology model show functions can used generate model steps. running DES, ’s important consider speed. Simulation based models can computationally expensive, means using efficient coding can substantial impact performance.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"main-options","dir":"Articles","previous_headings":"Introduction","what":"Main options","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"","code":"library(RDICE)  library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(ggplot2) library(kableExtra) #>  #> Attaching package: 'kableExtra' #> The following object is masked from 'package:dplyr': #>  #>     group_rows library(purrr) options(scipen = 999) options(digits=3) options(tibble.print_max = 50)"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"general-inputs-with-delayed-execution","dir":"Articles","previous_headings":"","what":"General inputs with delayed execution","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"Initial inputs flags used model can defined . can define inputs change across scenarios (sensitivity_inputs), inputs common patients (common_all_inputs) within simulation, inputs unique patient independently treatment (e.g. natural time death, defined common_pt_inputs), inputs unique patient treatment (unique_pt_inputs). Items can included add_item function, can used subsequent items. inputs generated events reaction events executed. Furthermore, program first executes common_all_inputs, common_pt_inputs unique_pt_inputs. one use items generated common_all_inputs unique_pt_inputs. Note inputs “reset” patient, patient 1 arm “noint” changes util.sick = 2, even ’s common parameter everyone, reset 1 patient 1 arm “int”. Note time death set common_pt_inputs, also just set add_tte function explained . user full flexibility implement type inputs. auxiliary functions help setting inputs, like pick_val_v pick_val (pick_psa, see section Sensitivity Analysis). Note pick_val_v pick_val can directly loaded parameters (fact, named list loaded directly R). small tweak needed ’s first item added, item list must initiated using add_item() (see ).","code":"#We don't need to use sensitivity_inputs here, so we don't add that object  #Put objects here that do not change on any patient or intervention loop common_all_inputs <-add_item(                       util.sick = 0.8,                       util.sicker = 0.5,                       cost.sick = 3000,                       cost.sicker = 7000,                       cost.int = 1000,                       coef_noint = log(0.2),                       HR_int = 0.8,                       drc = 0.035, #different values than what's assumed by default                       drq = 0.035) #different values than what's assumed by default   #Put objects here that do not change as we loop through treatments for a patient common_pt_inputs <- add_item(substream_sick   = parallel::nextRNGSubStream(.Random.seed),                              substream_sicker = parallel::nextRNGSubStream(substream_sick),                              substream_death  = parallel::nextRNGSubStream(substream_sicker),                              rnd_a = runif_stream(1,substream_sicker,gen=\"add_item\"),                              rnd_b = runif_stream(1,substream_death,gen=\"add_item\") )  #Put objects here that change as we loop through treatments for each patient (e.g. events can affect fl.tx, but events do not affect nat.os.s) unique_pt_inputs <- add_item(fl.sick = 1,                              q_default = util.sick,                              c_default = cost.sick + if(arm==\"int\"){cost.int}else{0})"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"add-initial-events","dir":"Articles","previous_headings":"Events","what":"Add Initial Events","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"Events added add_tte function. use function applying interventions. must define several arguments: one indicate intervention, one define names events used, one define names objects created like store (optional, maybe generate intermediate input event want save) actual input generate time event. Events objects automatically initialized Inf. draw times event patients. Note: order evts argument appears first used reference order process events case ties (“sick” processed “sicker” tie time event.) Note model use evnets defined evts argument look objects defined input list expression allocate time events. event declared evts defined elsewhere, assumed TTE Inf default. chunk bit complex, ’s worth spending bit time explaining . init_event_list object populated using add_tte function applies arms, “int” strategy “noint” strategy. first declare start time 0. Note also separated arm user wants clarity using two add_tte functions (.e., add_tte(arm=\"noint\"...) %>% add_tte(arm=\"int\"...)). proceed generate actual time event. use draw_tte() function generate time event, though one can set way (e.g., using rexp). One always aware competing risks interact . abstracted type corrections , recommended understanding affect results look competing risks/semi-competing risks literature.","code":"init_event_list <-    add_tte(arm=c(\"noint\",\"int\"), evts = c(\"sick\",\"sicker\",\"death\") ,input={ #intervention     sick <- 0     sicker <- qexp(rnd_a,exp(coef_noint + ifelse(arm==\"int\",log(HR_int),0)))     death <-  max(0.0000001,qnorm(rnd_b, mean=12, sd=3))   })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"add-reaction-to-those-events","dir":"Articles","previous_headings":"Events","what":"Add Reaction to Those Events","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"initial times events defined, also need declare events react affect . , use evt_react_list object add_reactevt function. function just needs state event affected, actual reaction (usually setting flags 1 0, creating new/adjusting events). series objects can used context help reactions. Apart global objects flags defined , can also use curtime current event time, prevtime time previous event, cur_evtlist named vector events yet happen patient, arm current treatment loop, evt current event processed, expresses patient iteration, simulation specific simulation (relevant number simulations greater 1). Furthermore, one can also call input/item created create new ones. example, even modify cost/utility item changing directly, e.g. modify_item(list(cost.idfs.tx=500)). functions add/modify events inputs use lists. Whenever several inputs/events added modified, ’s recommended group within one function, reduces computation cost. rather use two modify_item list one element, ’s better group single modify_item list two elements. new_eventallows generate events add vector events. accepts one event. modify_event allows modify events (e.g. delay death). adding event, name events time events must defined. using modify_event, one must indicate events affected new times events. event specified exist already occurred, ignored. modify_event create_if_null = TRUE argument also generate events don’t exist. Note one potentially omit part modeling set init_event_list actually define new events dynamically reactions (\"ae\" event). However, can impact computation time, possible ’s always better use init_event_list. modify_item modify_item_seqallow modify add items. Elements defined within function evaluated sequentially modify_item (.e. defining modify_item(list(fl.new = 1, var1 = fl.new * 5))) give error fl.new defined outside function), modify_item_seq sequentially slightly bigger computational cost, left choices user. Note one can modify costs/utilities using construction type_name_category, type either “qaly” “cost”, name name (e.g., “default”) category category used (e.g., “instant”), one pass cost_default_instant modify cost. list relevant functions used within add_reactevt : model run curtime set Inf, event terminates model (case, os), modify curtime set Inf. Finally, note two different ways accumulating continuous outcomes, backwards (.e., example , set q_default = util.sick sicker event, modify q_default value death event) forwards (example ). option can modified run_sim function using accum_backwards argument, assumes forwards default. use case luck adjustment update death time event using luck_adj function. parameters go mean 12 10, sd 3 2, update random number redraw time event. instead needed reset time event (case repeated independent events), set rnd_b = runif_stream(1,substream_death) regenerate luck.","code":"evt_react_list <-   add_reactevt(name_evt = \"sick\",                input = {}) %>%   add_reactevt(name_evt = \"sicker\",                input = {                  modify_item(list(q_default = util.sicker,                                   c_default = cost.sicker + if(arm==\"int\"){cost.int}else{0},                                   fl.sick = 0))                                                       #We perform a luck adjustment randomly but being slightly more likely in the \"noint\" arm                  if((runif(1) + ifelse(arm==\"noint\", 0.05,0) ) >0.8){                    modify_item(list(                      rnd_b = luck_adj(prevsurv = 1 - pnorm(q=curtime,12,3), cursurv = 1 - pnorm(q=curtime,10,2), luck = rnd_b, condq = FALSE)                      ))                                        modify_event(list(                      death = max(0.0000001,qnorm(rnd_b, mean=10, sd=2))                                      ))                  }                                                    }) %>%   add_reactevt(name_evt = \"death\",                input = {                  modify_item(list(q_default = 0,                                   c_default = 0,                                    curtime = Inf))                 })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"costs-and-utilities","dir":"Articles","previous_headings":"","what":"Costs and Utilities","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"Costs utilities introduced . However, ’s worth noting model able run without costs utilities. Utilities/Costs/outputs defined declaring object belongs utilities/costs/outputs, whether need discounted continuously discretely (instantaneous). passed run_sim function.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"utilities","dir":"Articles","previous_headings":"Costs and Utilities","what":"Utilities","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"","code":"util_ongoing <- \"q_default\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"costs","dir":"Articles","previous_headings":"Costs and Utilities","what":"Costs","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"","code":"cost_ongoing <- \"c_default\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"model-execution","dir":"Articles","previous_headings":"Model","what":"Model Execution","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"model can run using function run_sim . must define number patients simulated, number simulations, whether want run PSA , strategy list, inputs, events reactions defined , utilities, costs also want extra output level ipd data desired exported. worth noting psa_bool argument run PSA automatically, rather additional input/flag model use reference determine whether want use deterministic stochastic input. , also defined common_all_inputs first item defined, result . However, recommend defined run_sim. Note distribution chosen, number events interaction events can substantial impact running time model. Debugging can implemented using argument debug run_sim function.","code":"#Logic is: per patient, per intervention, per event, react to that event. results <- run_sim(     npats=1000,                               # number of patients to be simulated   n_sim=1,                                  # number of simulations to run   psa_bool = FALSE,                         # use PSA or not. If n_sim > 1 and psa_bool = FALSE, then difference in outcomes is due to sampling (number of pats simulated)     arm_list = c(\"int\", \"noint\"),             # intervention list   common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation   common_pt_inputs = common_pt_inputs,      # inputs that change within a simulation but are not affected by the intervention   unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions   init_event_list = init_event_list,        # initial event list   evt_react_list = evt_react_list,          # reaction of events   util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   ipd = 1 ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.95s\" #> [1] \"Time to run analysis 1: 0.95s\" #> [1] \"Total time to run: 0.95s\""},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"summary-of-results","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Summary of Results","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"model run, can use results summarize using summary_results_det print results last simulation (nsim = 1, ’s deterministic case), summary_results_sim show PSA results (confidence intervals). can also use individual patient data generated simulation, collect plot psa_ipd object. can also check absolute number events per strategy.","code":"summary_results_det(results[[1]][[1]]) #print first simulation #>                        int    noint #> costs             57932.84 50312.68 #> dcosts                0.00  7620.15 #> lys                   9.54     9.46 #> dlys                  0.00     0.08 #> qalys                 6.15     5.92 #> dqalys                0.00     0.23 #> ICER                    NA 92785.66 #> ICUR                    NA 33364.96 #> INMB                    NA  3799.24 #> costs_undisc      72522.53 63030.02 #> dcosts_undisc         0.00  9492.51 #> lys_undisc           11.71    11.58 #> dlys_undisc           0.00     0.13 #> qalys_undisc          7.44     7.14 #> dqalys_undisc         0.00     0.30 #> ICER_undisc             NA 73901.06 #> ICUR_undisc             NA 31849.68 #> INMB_undisc             NA  5409.54 #> c_default         57932.84 50312.68 #> dc_default            0.00  7620.15 #> c_default_undisc  72522.53 63030.02 #> dc_default_undisc     0.00  9492.51 #> q_default             6.15     5.92 #> dq_default            0.00     0.23 #> q_default_undisc      7.44     7.14 #> dq_default_undisc     0.00     0.30  summary_results_sim(results[[1]]) #>                                       int                   noint #> costs             57,933 (57,933; 57,933) 50,313 (50,313; 50,313) #> dcosts                           0 (0; 0)    7,620 (7,620; 7,620) #> lys                     9.54 (9.54; 9.54)       9.46 (9.46; 9.46) #> dlys                             0 (0; 0)    0.082 (0.082; 0.082) #> qalys                   6.15 (6.15; 6.15)       5.92 (5.92; 5.92) #> dqalys                           0 (0; 0)    0.228 (0.228; 0.228) #> ICER                         NaN (NA; NA) 92,786 (92,786; 92,786) #> ICUR                         NaN (NA; NA) 33,365 (33,365; 33,365) #> INMB                         NaN (NA; NA)    3,799 (3,799; 3,799) #> costs_undisc      72,523 (72,523; 72,523) 63,030 (63,030; 63,030) #> dcosts_undisc                    0 (0; 0)    9,493 (9,493; 9,493) #> lys_undisc              11.7 (11.7; 11.7)       11.6 (11.6; 11.6) #> dlys_undisc                      0 (0; 0)    0.128 (0.128; 0.128) #> qalys_undisc            7.44 (7.44; 7.44)       7.14 (7.14; 7.14) #> dqalys_undisc                    0 (0; 0)    0.298 (0.298; 0.298) #> ICER_undisc                  NaN (NA; NA) 73,901 (73,901; 73,901) #> ICUR_undisc                  NaN (NA; NA) 31,850 (31,850; 31,850) #> INMB_undisc                  NaN (NA; NA)    5,410 (5,410; 5,410) #> c_default         57,933 (57,933; 57,933) 50,313 (50,313; 50,313) #> dc_default                       0 (0; 0)    7,620 (7,620; 7,620) #> c_default_undisc  72,523 (72,523; 72,523) 63,030 (63,030; 63,030) #> dc_default_undisc                0 (0; 0)    9,493 (9,493; 9,493) #> q_default               6.15 (6.15; 6.15)       5.92 (5.92; 5.92) #> dq_default                       0 (0; 0)    0.228 (0.228; 0.228) #> q_default_undisc        7.44 (7.44; 7.44)       7.14 (7.14; 7.14) #> dq_default_undisc                0 (0; 0)    0.298 (0.298; 0.298)  summary_results_sens(results) #>        arm analysis analysis_name          variable                   value #>     <char>    <int>        <char>            <fctr>                  <char> #>  1:    int        1                           costs 57,933 (57,933; 57,933) #>  2:  noint        1                           costs 50,313 (50,313; 50,313) #>  3:    int        1                          dcosts                0 (0; 0) #>  4:  noint        1                          dcosts    7,620 (7,620; 7,620) #>  5:    int        1                             lys       9.54 (9.54; 9.54) #>  6:  noint        1                             lys       9.46 (9.46; 9.46) #>  7:    int        1                            dlys                0 (0; 0) #>  8:  noint        1                            dlys    0.082 (0.082; 0.082) #>  9:    int        1                           qalys       6.15 (6.15; 6.15) #> 10:  noint        1                           qalys       5.92 (5.92; 5.92) #> 11:    int        1                          dqalys                0 (0; 0) #> 12:  noint        1                          dqalys    0.228 (0.228; 0.228) #> 13:    int        1                            ICER            NaN (NA; NA) #> 14:  noint        1                            ICER 92,786 (92,786; 92,786) #> 15:    int        1                            ICUR            NaN (NA; NA) #> 16:  noint        1                            ICUR 33,365 (33,365; 33,365) #> 17:    int        1                            INMB            NaN (NA; NA) #> 18:  noint        1                            INMB    3,799 (3,799; 3,799) #> 19:    int        1                    costs_undisc 72,523 (72,523; 72,523) #> 20:  noint        1                    costs_undisc 63,030 (63,030; 63,030) #> 21:    int        1                   dcosts_undisc                0 (0; 0) #> 22:  noint        1                   dcosts_undisc    9,493 (9,493; 9,493) #> 23:    int        1                      lys_undisc       11.7 (11.7; 11.7) #> 24:  noint        1                      lys_undisc       11.6 (11.6; 11.6) #> 25:    int        1                     dlys_undisc                0 (0; 0) #> 26:  noint        1                     dlys_undisc    0.128 (0.128; 0.128) #> 27:    int        1                    qalys_undisc       7.44 (7.44; 7.44) #> 28:  noint        1                    qalys_undisc       7.14 (7.14; 7.14) #> 29:    int        1                   dqalys_undisc                0 (0; 0) #> 30:  noint        1                   dqalys_undisc    0.298 (0.298; 0.298) #> 31:    int        1                     ICER_undisc            NaN (NA; NA) #> 32:  noint        1                     ICER_undisc 73,901 (73,901; 73,901) #> 33:    int        1                     ICUR_undisc            NaN (NA; NA) #> 34:  noint        1                     ICUR_undisc 31,850 (31,850; 31,850) #> 35:    int        1                     INMB_undisc            NaN (NA; NA) #> 36:  noint        1                     INMB_undisc    5,410 (5,410; 5,410) #> 37:    int        1                       c_default 57,933 (57,933; 57,933) #> 38:  noint        1                       c_default 50,313 (50,313; 50,313) #> 39:    int        1                      dc_default                0 (0; 0) #> 40:  noint        1                      dc_default    7,620 (7,620; 7,620) #> 41:    int        1                c_default_undisc 72,523 (72,523; 72,523) #> 42:  noint        1                c_default_undisc 63,030 (63,030; 63,030) #> 43:    int        1               dc_default_undisc                0 (0; 0) #> 44:  noint        1               dc_default_undisc    9,493 (9,493; 9,493) #> 45:    int        1                       q_default       6.15 (6.15; 6.15) #> 46:  noint        1                       q_default       5.92 (5.92; 5.92) #> 47:    int        1                      dq_default                0 (0; 0) #> 48:  noint        1                      dq_default    0.228 (0.228; 0.228) #> 49:    int        1                q_default_undisc       7.44 (7.44; 7.44) #> 50:  noint        1                q_default_undisc       7.14 (7.14; 7.14) #> 51:    int        1               dq_default_undisc                0 (0; 0) #> 52:  noint        1               dq_default_undisc    0.298 (0.298; 0.298) #>        arm analysis analysis_name          variable                   value  psa_ipd <- bind_rows(map(results[[1]], \"merged_df\"))   psa_ipd[1:10,] %>%   kable() %>%   kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\"))"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"plots","dir":"Articles","previous_headings":"Post-processing of Model Outputs","what":"Plots","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"now use data output plot histograms/densities simulation.  can also plot patient level incremental QALY/costs.","code":"data_plot <- results[[1]][[1]]$merged_df %>%   filter(evtname != \"sick\") %>%   group_by(arm,evtname,simulation) %>%   mutate(median = median(evttime)) %>%   ungroup()  ggplot(data_plot) +   geom_density(aes(fill = arm, x = evttime),                alpha = 0.7) +   geom_vline(aes(xintercept=median,col=arm)) +   facet_wrap( ~ evtname, scales = \"free\") +   scale_y_continuous(expand = c(0, 0)) +   scale_x_continuous(expand = c(0, 0)) +   theme_bw() data_qaly_cost<- psa_ipd[,.SD[1],by=.(pat_id,arm,simulation)][,.(arm,qaly=total_qalys,cost=total_costs,pat_id,simulation)] data_qaly_cost[,ps_id:=paste(pat_id,simulation,sep=\"_\")]   mean_data_qaly_cost <- data_qaly_cost %>% group_by(arm) %>% summarise(across(where(is.numeric),mean))  ggplot(data_qaly_cost,aes(x=qaly, y = cost, col = arm)) +    geom_point(alpha=0.15,shape = 21) +   geom_point(data=mean_data_qaly_cost, aes(x=qaly, y = cost, fill = arm), shape = 21,col=\"black\",size=3) +   scale_y_continuous(expand = c(0, 0)) +   scale_x_continuous(expand = c(0, 0)) +   theme_bw()+   theme(axis.text.x = element_text(angle = 90, vjust = .5))"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"inputs","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Inputs","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"case, inputs must created first change across sensitivity analysis. , item list sensitivity_inputs can used. case, also use pick_val_v allows model automatically pick relevant value (PSA, PSA sensitivity analysis) based corresponding boolean flags psa_bool sensitivity_bool. case also use sens iterator sensitivity analysis n_sensitivity argument run_sim. Note just changed inputs handled common_all_inputs, done unique_pt_inputs, cases, inputs change per patient, pick_val_v pick_val functions applied within unique_pt_inputs make sure evaluated correspond. Note psa directly calling distributions passing parameters.Note also sens_name_used automatically computed engine accesible user (’s name sensitivity analysis, e.g., “scenario 1”). indicator parameter pick_val_v pick_val used determine parameters left “” ones substituted sensitivity value. two ways , either setting binary way (1 0), using indicator number parameter values varied (useful several parameters varied time, specific values vector varied). can set using indicator_sens_binary argument. Note pick_val_v pick_val can directly loaded parameters (fact, named list loaded directly R). small tweak needed ’s first item added, item list must initiated using add_item() (see ). pick_psa can used select correct PSA distributions.","code":"#Load some data df_par <- data.frame(parameter_name = c(\"util.sick\",\"util.sicker\",\"cost.sick\",\"cost.sicker\",\"cost.int\",\"coef_noint\",\"HR_int\"),                               base_value = c(0.8,0.5,3000,7000,1000,log(0.2),0.8),                               DSA_min = c(0.6,0.3,1000,5000,800,log(0.1),0.5),                               DSA_max = c(0.9,0.7,5000,9000,2000,log(0.4),0.9),                               PSA_dist = c(\"rnorm\",\"rbeta_mse\",\"rgamma_mse\",\"rgamma_mse\",\"rgamma_mse\",\"rnorm\",\"rlnorm\"),                               a=c(0.8,0.5,3000,7000,1000,log(0.2),0.8),                               b=c(0.8,0.5,3000,7000,1000,0.1,0.8)/5,                               scenario_1=c(0.6,0.3,1000,5000,800,log(0.1),0.5),                               scenario_2=c(0.9,0.7,5000,9000,2000,log(0.4),0.9)                               ) rownames(df_par) <- df_par$parameter_name  sensitivity_inputs <-add_item(             pos_indicator = sens - n_sensitivity*floor((sens-1)/n_sensitivity), # which position to use to put the value 1 in indicator             indicators = append(rep(0, nrow(df_par))[-pos_indicator],1,pos_indicator-1), #vector of indicators, value 0 everywhere except at sens, where it takes value 1                               )  common_all_inputs <-add_item() %>%    add_item(             pick_val_v(base        = df_par[,\"base_value\"],                        psa         = pick_psa(df_par[,\"PSA_dist\"],rep(1,length(df_par[,\"PSA_dist\"])),df_par[,\"a\"],df_par[,\"b\"]),                        sens        = df_par[,sens_name_used],                        psa_ind     = psa_bool,                        sens_ind    = sensitivity_bool,                        indicator   = indicators,                        names_out   = df_par[,\"parameter_name\"]                        )             )"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"model-execution-1","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Model Execution","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"model executed , just adding sensitivity_inputs, sensitivity_names, sensitivity_bool n_sensitivity arguments. Note total number sensitivity iterations given n_sensitivity, n_sensitivity * length(sensitivity_names), case 2 x n_sensitivity, 2 x 7 = 14. two scenario analysis 2 x 1 = 2, indicators variable defined previous section taking value 1 variables altered scenario, 0 otherwise.","code":"results <- run_sim(     npats=100,                               # number of patients to be simulated   n_sim=1,                                  # number of simulations to run   psa_bool = FALSE,                         # use PSA or not. If n_sim > 1 and psa_bool = FALSE, then difference in outcomes is due to sampling (number of pats simulated)     arm_list = c(\"int\", \"noint\"),             # intervention list   common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation   common_pt_inputs = common_pt_inputs,      # inputs that change within a simulation but are not affected by the intervention   unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions   init_event_list = init_event_list,        # initial event list   evt_react_list = evt_react_list,          # reaction of events   util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   sensitivity_inputs = sensitivity_inputs,   sensitivity_names = c(\"DSA_min\",\"DSA_max\"),   sensitivity_bool = TRUE,   n_sensitivity = nrow(df_par),   input_out = c(df_par[,\"parameter_name\"]) ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Time to run analysis 1: 0.18s\" #> [1] \"Analysis number: 2\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 2: 0.18s\" #> [1] \"Analysis number: 3\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 3: 0.17s\" #> [1] \"Analysis number: 4\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Time to run analysis 4: 0.18s\" #> [1] \"Analysis number: 5\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 5: 0.17s\" #> [1] \"Analysis number: 6\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 6: 0.17s\" #> [1] \"Analysis number: 7\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Time to run analysis 7: 0.18s\" #> [1] \"Analysis number: 8\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 8: 0.17s\" #> [1] \"Analysis number: 9\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Time to run analysis 9: 0.18s\" #> [1] \"Analysis number: 10\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Time to run analysis 10: 0.18s\" #> [1] \"Analysis number: 11\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 11: 0.17s\" #> [1] \"Analysis number: 12\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.19s\" #> [1] \"Time to run analysis 12: 0.19s\" #> [1] \"Analysis number: 13\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Time to run analysis 13: 0.18s\" #> [1] \"Analysis number: 14\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Time to run analysis 14: 0.17s\" #> [1] \"Total time to run: 2.47s\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"check-results","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Check results","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"briefly check indeed engine changing corresponding parameter value.","code":"data_sensitivity <- bind_rows(map_depth(results,2, \"merged_df\"))  #Check mean value across iterations as PSA is off data_sensitivity %>% group_by(sensitivity) %>% summarise_at(c(\"util.sick\",\"util.sicker\",\"cost.sick\",\"cost.sicker\",\"cost.int\",\"coef_noint\",\"HR_int\"),mean) #> # A tibble: 14 × 8 #>    sensitivity util.sick util.sicker cost.sick cost.sicker cost.int coef_noint #>          <int>     <dbl>       <dbl>     <dbl>       <dbl>    <dbl>      <dbl> #>  1           1       0.6         0.5      3000        7000     1000     -1.61  #>  2           2       0.8         0.3      3000        7000     1000     -1.61  #>  3           3       0.8         0.5      1000        7000     1000     -1.61  #>  4           4       0.8         0.5      3000        5000     1000     -1.61  #>  5           5       0.8         0.5      3000        7000      800     -1.61  #>  6           6       0.8         0.5      3000        7000     1000     -2.30  #>  7           7       0.8         0.5      3000        7000     1000     -1.61  #>  8           8       0.9         0.5      3000        7000     1000     -1.61  #>  9           9       0.8         0.7      3000        7000     1000     -1.61  #> 10          10       0.8         0.5      5000        7000     1000     -1.61  #> 11          11       0.8         0.5      3000        9000     1000     -1.61  #> 12          12       0.8         0.5      3000        7000     2000     -1.61  #> 13          13       0.8         0.5      3000        7000     1000     -0.916 #> 14          14       0.8         0.5      3000        7000     1000     -1.61  #> # ℹ 1 more variable: HR_int <dbl>"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"model-execution-probabilistic-dsa","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Model Execution, probabilistic DSA","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"model executed , just activating psa_bool option","code":"results <- run_sim(     npats=100,                                  n_sim=6,                                     psa_bool = TRUE,                            arm_list = c(\"int\", \"noint\"),                common_all_inputs = common_all_inputs,       common_pt_inputs = common_pt_inputs,         unique_pt_inputs = unique_pt_inputs,         init_event_list = init_event_list,           evt_react_list = evt_react_list,             util_ongoing_list = util_ongoing,   cost_ongoing_list = cost_ongoing,   sensitivity_inputs = sensitivity_inputs,   sensitivity_names = c(\"DSA_min\",\"DSA_max\"),   sensitivity_bool = TRUE,   n_sensitivity = nrow(df_par),   input_out = c(df_par[,\"parameter_name\"]) ) #> [1] \"Analysis number: 1\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.19s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.38s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 1: 1.25s\" #> [1] \"Analysis number: 2\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 2: 1.04s\" #> [1] \"Analysis number: 3\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 3: 1.04s\" #> [1] \"Analysis number: 4\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 4: 1.06s\" #> [1] \"Analysis number: 5\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.19s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 5: 1.07s\" #> [1] \"Analysis number: 6\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.17s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.17s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.21s\" #> [1] \"Time to run analysis 6: 1.08s\" #> [1] \"Analysis number: 7\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.17s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.17s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 7: 1.07s\" #> [1] \"Analysis number: 8\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.18s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.19s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 8: 1.08s\" #> [1] \"Analysis number: 9\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.19s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.19s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.19s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.19s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.18s\" #> [1] \"Time to run analysis 9: 1.11s\" #> [1] \"Analysis number: 10\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.19s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.19s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 10: 1.09s\" #> [1] \"Analysis number: 11\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.19s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.17s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.19s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.17s\" #> [1] \"Time to run analysis 11: 1.09s\" #> [1] \"Analysis number: 12\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.19s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.21s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.18s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.2s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.2s\" #> [1] \"Time to run analysis 12: 1.15s\" #> [1] \"Analysis number: 13\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.2s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.19s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.19s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.18s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.2s\" #> [1] \"Time to run analysis 13: 1.13s\" #> [1] \"Analysis number: 14\" #> [1] \"Simulation number: 1\" #> [1] \"Time to run simulation 1: 0.19s\" #> [1] \"Simulation number: 2\" #> [1] \"Time to run simulation 2: 0.18s\" #> [1] \"Simulation number: 3\" #> [1] \"Time to run simulation 3: 0.2s\" #> [1] \"Simulation number: 4\" #> [1] \"Time to run simulation 4: 0.18s\" #> [1] \"Simulation number: 5\" #> [1] \"Time to run simulation 5: 0.19s\" #> [1] \"Simulation number: 6\" #> [1] \"Time to run simulation 6: 0.19s\" #> [1] \"Time to run analysis 14: 1.13s\" #> [1] \"Total time to run: 15.39s\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_ssd_stream.html","id":"check-results-1","dir":"Articles","previous_headings":"Sensitivity Analysis","what":"Check results","title":"Example for a Sick-Sicker-Dead model - Random Number Substreams & Luck Adjustment","text":"briefly check indeed engine changing corresponding parameter value.","code":"data_sensitivity <- bind_rows(map_depth(results,2, \"merged_df\"))  #Check mean value across iterations as PSA is off data_sensitivity %>% group_by(sensitivity) %>% summarise_at(c(\"util.sick\",\"util.sicker\",\"cost.sick\",\"cost.sicker\",\"cost.int\",\"coef_noint\",\"HR_int\"),mean) #> # A tibble: 14 × 8 #>    sensitivity util.sick util.sicker cost.sick cost.sicker cost.int coef_noint #>          <int>     <dbl>       <dbl>     <dbl>       <dbl>    <dbl>      <dbl> #>  1           1     0.6         0.579     3144.       7963.    1066.     -1.61  #>  2           2     0.724       0.3       3144.       7963.    1066.     -1.61  #>  3           3     0.724       0.579     1000        7963.    1066.     -1.61  #>  4           4     0.724       0.579     3144.       5000     1066.     -1.61  #>  5           5     0.724       0.579     3144.       7963.     800      -1.61  #>  6           6     0.724       0.579     3142.       7962.    1066.     -2.30  #>  7           7     0.724       0.579     3143.       7964.    1066.     -1.61  #>  8           8     0.9         0.579     3144.       7963.    1066.     -1.61  #>  9           9     0.724       0.7       3144.       7963.    1066.     -1.61  #> 10          10     0.724       0.579     5000        7963.    1066.     -1.61  #> 11          11     0.724       0.579     3144.       9000     1066.     -1.61  #> 12          12     0.724       0.579     3144.       7963.    2000      -1.61  #> 13          13     0.724       0.579     3143.       7962.    1066.     -0.916 #> 14          14     0.724       0.579     3144.       7964.    1066.     -1.61  #> # ℹ 1 more variable: HR_int <dbl>"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Structural and Parametric Uncertainty","text":"document runs discrete event simulation model context early breast cancer show uncertainty behaves simulation setting complements standard PSA. model extremely similar example early breast cancer, user can check original model details functions, parameters etc.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"main-options","dir":"Articles","previous_headings":"Introduction","what":"Main options","title":"Structural and Parametric Uncertainty","text":"","code":"library(RDICE)  library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(purrr) library(tidyr) library(flexsurv) #> Loading required package: survival library(ggplot2) library(kableExtra) #>  #> Attaching package: 'kableExtra' #> The following object is masked from 'package:dplyr': #>  #>     group_rows"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"load-data","dir":"Articles","previous_headings":"Introduction","what":"Load Data","title":"Structural and Parametric Uncertainty","text":"dummy data costs utility generated .","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"general-inputs-with-delayed-execution","dir":"Articles","previous_headings":"","what":"General inputs with delayed execution","title":"Structural and Parametric Uncertainty","text":"Initial inputs flags used model can defined . exactly original model, difference now adding extra chunk reflects uncertainty parameters draw distributions. Furthermore, utilities costs also distribution.","code":"#Each patient is identified through \"i\" #Items used in the model should be unnamed numeric/vectors! otherwise if they are processed by model it can lead to strangely named outcomes #In this case, util_v is a named vector, but it's not processed by the model. We extract unnamed numerics from it.  #Put objects here that do not change on any patient or intervention loop common_all_inputs <- add_item() %>%   add_item( #utilities   pick_val_v(     base =  util.data$value,     psa = MASS::mvrnorm(1,util.data$value,diag(util.data$se^2)),     sens = util.data$value,     psa_ind = psa_bool,     sens_ind = sensitivity_bool,     indicator = rep(0, nrow(util.data)),     names_out =util.data$name   ),#costs   pick_val_v(     base =  cost.data$value,     psa = rgamma_mse(1,cost.data$value,cost.data$se),     sens = cost.data$value,     psa_ind = psa_bool,     sens_ind = sensitivity_bool,     indicator = rep(0, nrow(cost.data)),     names_out =cost.data$name   ) ) %>%   add_item( #parameter uncertainty, alternative approach to using pick_val_v, it also does work     coef11_psa = ifelse(psa_bool,rnorm(1,2,0.1),2),     coef12_psa = ifelse(psa_bool,rnorm(1,3,0.1),3),     coef13_psa = ifelse(psa_bool,rnorm(1,0.8,0.05),0.8),     coef14_psa = ifelse(psa_bool,rnorm(1,0.5,0.05),0.5),     coef15_psa = ifelse(psa_bool,rnorm(1,2.3,0.1),2.3),     coef16_psa = ifelse(psa_bool,log(rnorm(1,0.08,0.005)),log(0.08)),     coef2_psa = ifelse(psa_bool,log(rnorm(1,0.2,0.01)),log(0.2)),     hr_psa = ifelse(psa_bool,exp(rnorm(1,log(1.2),0.05)),1.2)     )  #Put objects here that do not change as we loop through interventions for a patient common_pt_inputs <- add_item(sex_pt = ifelse(rbinom(1,1,p=0.01),\"male\",\"female\"),                              nat.os.s = rcond_gompertz(1,                                                      shape=if(sex_pt==\"male\"){0.102}else{0.115},                                                      rate=if(sex_pt==\"male\"){0.000016}else{0.0000041},                                                      lower_bound = 50) ) #in years, for a patient who is 50yo  #Put objects here that change as we loop through treatments for each patient (e.g. events can affect fl.tx, but events do not affect nat.os.s) #common across arm but changes per pt could be implemented here (if (arm==)... ) unique_pt_inputs <- add_item(   fl.idfs.ontx             = 1,   fl.idfs                  = 1,   fl.mbcs.ontx             = 1,   fl.mbcs.progression.mbc  = 1,   fl.tx.beva               = 1,     fl.mbcs                  = 0,   fl.mbcs_2ndline          = 0,   fl.recurrence            = 0,   fl.remission             = rbinom(1,1,0.8), #80% probability of going into remission   q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },   c_default = if(arm==\"noint\"){cost.idfs.txnoint* fl.idfs.ontx  + cost.idfs}else{(cost.idfs.tx) * fl.idfs.ontx + cost.tx.beva * fl.tx.beva + cost.idfs},   c_ae = 0 )"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"add-initial-events","dir":"Articles","previous_headings":"Events","what":"Add Initial Events","title":"Structural and Parametric Uncertainty","text":"Events generated , difference parameters simple number objects created part common_all_inputs.","code":"init_event_list <-    add_tte(arm=\"int\",                evts = c(\"start\",\"ttot\", \"ttot.beva\",\"progression.mbc\", \"os\",\"idfs\",\"ttot.early\",\"remission\",\"recurrence\",\"start.early.mbc\",\"ae\",\"2ndline_mbc\"),                other_inp = c(\"os.early\",\"os.mbc\"),                input={ #intervention     start <- 0          #Early          idfs <- draw_tte(1,'lnorm',coef1=coef11_psa, coef2=coef2_psa)      ttot.early <- min(draw_tte(1,'lnorm',coef1=coef11_psa, coef2=coef2_psa),idfs)     ttot.beva <- draw_tte(1,'lnorm',coef1=coef11_psa, coef2=coef2_psa)      os.early <- draw_tte(1,'lnorm',coef1=coef12_psa, coef2=coef2_psa)           #if patient has remission, check when will recurrence happen     if (fl.remission) {        recurrence <- idfs + draw_tte(1,'lnorm',coef1=coef11_psa, coef2=coef2_psa)       remission <- idfs              #if recurrence happens before death       if (min(os.early,nat.os.s)>recurrence) {                   #Late metastatic (after finishing idfs and recurrence)                  os.mbc <- draw_tte(1,'lnorm',coef1=coef13_psa, coef2=coef2_psa) + idfs  +  recurrence                   progression.mbc <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + idfs +  recurrence                   ttot <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + idfs +  recurrence                         }            } else{ #If early metastatic       start.early.mbc <- draw_tte(1,'lnorm',coef1=coef15_psa, coef2=coef2_psa)              idfs <- ifelse(start.early.mbc<idfs,start.early.mbc,idfs)       ttot.early <- min(ifelse(start.early.mbc<idfs,start.early.mbc,idfs),ttot.early)              os.mbc <- draw_tte(1,'lnorm',coef1=coef13_psa, coef2=coef2_psa) + start.early.mbc              progression.mbc <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + start.early.mbc              ttot <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + start.early.mbc            }          os <- min(os.mbc,os.early,nat.os.s)         }) %>%  add_tte(arm=\"noint\",                        evts = c(\"start\",\"ttot\", \"ttot.beva\",\"progression.mbc\", \"os\",\"idfs\",\"ttot.early\",\"remission\",\"recurrence\",\"start.early.mbc\"),                        other_inp = c(\"os.early\",\"os.mbc\"),                                               input={  #reference strategy     start <- 0      #Early          idfs <- draw_tte(1,'lnorm',coef1=coef11_psa, coef2=coef2_psa,beta_tx = hr_psa)      ttot.early <- min(draw_tte(1,'lnorm',coef1=coef11_psa, coef2=coef2_psa,beta_tx = hr_psa),idfs)          os.early <- draw_tte(1,'lnorm',coef1=coef12_psa, coef2=coef2_psa,beta_tx = hr_psa)           #if patient has remission, check when will recurrence happen     if (fl.remission) {        recurrence <- idfs +draw_tte(1,'lnorm',coef1=coef11_psa, coef2=coef2_psa)       remission <- idfs              #if recurrence happens before death       if (min(os.early,nat.os.s)>recurrence) {                   #Late metastatic (after finishing idfs and recurrence)                  os.mbc <- draw_tte(1,'lnorm',coef1=coef13_psa, coef2=coef2_psa) + idfs  +  recurrence                   progression.mbc <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + idfs +  recurrence                   ttot <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + idfs +  recurrence                }            } else{ #If early metastatic       start.early.mbc <- draw_tte(1,'lnorm',coef1=coef15_psa, coef2=coef2_psa)              idfs <- ifelse(start.early.mbc<idfs,start.early.mbc,idfs)       ttot.early <- min(ifelse(start.early.mbc<idfs,start.early.mbc,idfs),ttot.early)              os.mbc <- draw_tte(1,'lnorm',coef1=coef13_psa, coef2=coef2_psa) + start.early.mbc              progression.mbc <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + start.early.mbc              ttot <- draw_tte(1,'lnorm',coef1=coef14_psa, coef2=coef2_psa) + start.early.mbc                   }         os <- min(os.mbc,os.early,nat.os.s)        })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"add-reaction-to-those-events","dir":"Articles","previous_headings":"Events","what":"Add Reaction to Those Events","title":"Structural and Parametric Uncertainty","text":"reactions set fashion original model. small modification made generating event 2ndline_mbc, now also uses random parameter PSA option active.","code":"evt_react_list <-   add_reactevt(name_evt = \"start\",                input = {}) %>%   add_reactevt(name_evt = \"ttot\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = if(arm==\"noint\"){cost.idfs.txnoint* fl.idfs.ontx  + cost.idfs}else{(cost.idfs.tx) * fl.idfs.ontx + cost.tx.beva * fl.tx.beva + cost.idfs},                               \"fl.mbcs.ontx\"= 0)) #Flag that patient is now off-treatment                                  }) %>%   add_reactevt(name_evt = \"ttot.beva\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.tx.beva\"= 0)) #Flag that patient is now off-treatment                                  }) %>%   add_reactevt(name_evt = \"progression.mbc\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.mbcs.progression.mbc\"=0,                               \"fl.mbcs_2ndline\"=1)) #Flag that patient is progressed and going in 2nd line                                    new_event(list(\"2ndline_mbc\" = curtime + draw_tte(1,'exp', coef16_psa)/12))                                  }) %>%   add_reactevt(name_evt = \"idfs\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = if(arm==\"noint\"){cost.idfs.txnoint* fl.idfs.ontx  + cost.idfs}else{(cost.idfs.tx) * fl.idfs.ontx + cost.tx.beva * fl.tx.beva + cost.idfs},                               \"fl.idfs\"= 0))                                  }) %>%   add_reactevt(name_evt = \"ttot.early\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = if(arm==\"noint\"){cost.idfs.txnoint* fl.idfs.ontx  + cost.idfs}else{(cost.idfs.tx) * fl.idfs.ontx + cost.tx.beva * fl.tx.beva + cost.idfs},                               \"fl.idfs.ontx\"=0,                               \"fl.tx.beva\"=0)) #Flag that patient is now off-treatment                                    n_ae <- rpois(1,lambda=0.25*(curtime -prevtime)) #1 AE every 4 years                                    if (n_ae>0) {                    new_event(rep(list(\"ae\" = curtime + 0.0001),n_ae))                  }                }) %>%   add_reactevt(name_evt = \"remission\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.recurrence * fl.recurrence,                               \"fl.remission\"= 1))                                  }) %>%   add_reactevt(name_evt = \"recurrence\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.recurrence * fl.recurrence,                               \"fl.recurrence\"=1,                               \"fl.remission\"=0,                               \"fl.mbcs\"=1,                               \"fl.mbcs.progression.mbc\"=1)) #ad-hoc for plot                                  }) %>%   add_reactevt(name_evt = \"start.early.mbc\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.recurrence * fl.recurrence,                               \"fl.mbcs\"=1,                               \"fl.mbcs.progression.mbc\"=1))                                  }) %>%   add_reactevt(name_evt = \"2ndline_mbc\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.mbcs_2ndline\"= 0))                                    n_ae <- rpois(1,lambda=0.25*(curtime -prevtime)) #1 AE every 4 years                                    if (n_ae>0) {                    new_event(rep(list(\"ae\" = curtime + 0.0001),n_ae))                  }                }) %>%   add_reactevt(name_evt = \"ae\",                input = {                                    modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               c_ae = cost.ae))                                    modify_event(list(                               \"os\" = max(cur_evtlist[[\"os\"]] - 0.125,curtime +0.0001) ))#each AE brings forward death by 1.5 months                }) %>%   add_reactevt(name_evt = \"os\",                input = {                  modify_item(list(q_default = if (fl.idfs==1) {                                 util.idfs.ontx * fl.idfs.ontx + (1-fl.idfs.ontx) * (1-fl.idfs.ontx)                                } else if (fl.idfs==0 & fl.mbcs==0) {                                 util.remission * fl.remission + fl.recurrence*util.recurrence                               } else if (fl.mbcs==1) {                                 util.mbc.progression.mbc * fl.mbcs.progression.mbc + (1-fl.mbcs.progression.mbc)*util.mbc.pps                               },                               c_default = cost.mbc.tx  * fl.mbcs.ontx + cost.mbc.progression.mbc * fl.mbcs.progression.mbc + cost.mbc.pps * (1-fl.mbcs.progression.mbc) + cost.2ndline*fl.mbcs_2ndline,                               \"fl.tx.beva\"=0,                               \"fl.mbcs.ontx\"=0,                               \"fl.idfs\"=0,                               \"fl.mbcs\"=0,                               \"curtime\"=Inf))                 })"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"costs-and-utilities","dir":"Articles","previous_headings":"","what":"Costs and Utilities","title":"Structural and Parametric Uncertainty","text":"Costs utilities introduced .","code":"util_ongoing <- \"q_default\"  cost_ongoing <- \"c_default\"  cost_instant <-  \"c_ae\""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"model","dir":"Articles","previous_headings":"","what":"Model","title":"Structural and Parametric Uncertainty","text":"model can now executed normal. Given modeling exercise relies sampling distributions simulating finite number patients, randomness involved can affect results, even assumption parameters fixed. However, running patients also means simulation slower, trade-accuracy speed. important question understand much uncertainty observe running PSA comes parametric uncertainty much comes fact simulating finite sample.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"structural-uncertainty","dir":"Articles","previous_headings":"Model","what":"Structural Uncertainty","title":"Structural and Parametric Uncertainty","text":"One way test run simulations increasing number patients simulated. example, run 6 deterministic simulations 50, 100, 500, 1,000 patients, show model outcome can change depending random seed used. Note exercise can time consuming. ’s important note optimal number patients simulated depend dispersion distributions, patient pathway, number possible outcomes difference among . example, event low probability high impact variability implies higher number patients simulated order obtain stable outcomes. test, set psa_bool = FALSE (optional) set ipd = FALSE. last option means exporting IPD data simulations, rather aggregate outcomes (last simulation, included default). important simulating large number patients lot simulations, can generate large objects (>1 GB). option can also especially relevant running PSA, require psa_bool = TRUE high number simulations. can plot results (case, costs, lys qalys “noint” intervention) can also try understand relative size uncertainty provided sampling. compute coefficient variation outcomes exported (costs, qalys, lys, ICER ICUR). first thing noticed ICER ICUR CV much higher costs/lys/qalys. incremental nature ICER/ICUR, means ’s sensitive small variations outputs. costs/qalys/lys quite precise reduced number simulations (~1,000), order precise ICER/ICUR need go higher (~5,000/10,000). However, one see mean quite stable ~5,000 patients. can plot CV see clearly:","code":"sample_sizes <- c(50,100,500,1000)  sim_size_df <- NULL for (sample_size in sample_sizes) {   results <- suppressWarnings( #run without warnings       run_sim(       npats=sample_size,                        # number of patients to be simulated     n_sim=6,                                # number of simulations to run     psa_bool = FALSE,                         # use PSA or not. If n_sim > 1 and psa_bool = FALSE, then difference in outcomes is due to sampling (number of pats simulated)     arm_list = c(\"int\", \"noint\"),             # intervention list     common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation     common_pt_inputs = common_pt_inputs,      # inputs that change within a simulation but are not affected by the intervention     unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions     init_event_list = init_event_list,        # initial event list     evt_react_list = evt_react_list,          # reaction of events     util_ongoing_list = util_ongoing,     cost_ongoing_list = cost_ongoing,     cost_instant_list = cost_instant,     ipd=FALSE                                 # Return IPD data through merged_df? Set to FALSE as it's not of interest here and it makes code slower   ))     #We're extracting the overall ICER/ICUR and also costs/qalys/lys for the \"noint\" intervention   loop_df <- rbind(extract_psa_result(results[[1]],\"total_costs\"),                    extract_psa_result(results[[1]],\"total_lys\"),                    extract_psa_result(results[[1]],\"total_qalys\"))      loop_df <- rbind(loop_df %>%                      pivot_longer(cols=c(\"int\",\"noint\"),names_to=\"arm\"),                    loop_df %>%                      mutate(dif = int - noint) %>%                      group_by(simulation) %>%                      transmute(value = dif[element==\"total_costs\"]/dif[element==\"total_qalys\"],element = \"ICUR\", arm=\"noint\") %>%                      relocate(element, arm) %>%                      ungroup() %>%                      distinct())         loop_df$sample_size <- sample_size   sim_size_df <- rbind(sim_size_df,loop_df)    }"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"parameter-uncertainty","dir":"Articles","previous_headings":"Model","what":"Parameter Uncertainty","title":"Structural and Parametric Uncertainty","text":"Structural uncertainty type uncertainty model can . Parameters can also changed across simulations using psa_bool = TRUE option. Let’s see happens compare true PSA structural uncertainty 1,000 patients. Now uncertainty much bigger compared case 1,000 iterations parameter uncertainty.","code":"sample_sizes <- 1000  sim_size_psa_df <- NULL for (sample_size in sample_sizes) {   results <- suppressWarnings( #run without warnings       run_sim(       npats=sample_size,                        # number of patients to be simulated     n_sim=6,                                # number of simulations to run     psa_bool = TRUE,                         # use PSA or not. If n_sim > 1 and psa_bool = FALSE, then difference in outcomes is due to sampling (number of pats simulated)     arm_list = c(\"int\", \"noint\"),             # intervention list     common_all_inputs = common_all_inputs,    # inputs common that do not change within a simulation     common_pt_inputs = common_pt_inputs,      # inputs that change within a simulation but are not affected by the intervention     unique_pt_inputs = unique_pt_inputs,      # inputs that change within a simulation between interventions     init_event_list = init_event_list,        # initial event list     evt_react_list = evt_react_list,          # reaction of events     util_ongoing_list = util_ongoing,     cost_ongoing_list = cost_ongoing,     cost_instant_list = cost_instant,     ipd=FALSE                                 # Return IPD data through merged_df? Set to FALSE as it's not of interest here and it makes code slower   ))     #We're extracting the overall ICER/ICUR and also costs/qalys/lys for the \"noint\" intervention   loop_psa_df <- rbind(extract_psa_result(results[[1]],\"total_costs\"),                    extract_psa_result(results[[1]],\"total_lys\"),                    extract_psa_result(results[[1]],\"total_qalys\"))      loop_psa_df <- rbind(loop_psa_df %>%                      pivot_longer(cols=c(\"int\",\"noint\"),names_to=\"arm\"),                    loop_psa_df %>%                      mutate(dif = int - noint) %>%                      group_by(simulation) %>%                      transmute(value = dif[element==\"total_costs\"]/dif[element==\"total_qalys\"],element = \"ICUR\", arm=\"noint\") %>%                      relocate(element, arm) %>%                      ungroup() %>%                      distinct())      loop_psa_df$sample_size  <-  sample_size   sim_size_psa_df <- rbind(sim_size_psa_df,loop_psa_df)    }"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"ceacceaf-and-evpi","dir":"Articles","previous_headings":"","what":"CEAC/CEAF and EVPI","title":"Structural and Parametric Uncertainty","text":"PSA run, additional analyses can performed understand importance behavior uncertainty.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"ceacceaf","dir":"Articles","previous_headings":"CEAC/CEAF and EVPI","what":"CEAC/CEAF","title":"Structural and Parametric Uncertainty","text":"can now use ceac_des function vector willingness pay results PSA generate CEAC CEAF plots.","code":"wtp <- seq(from=0,to=150000,by=1000) ceac_out <-ceac_des(wtp,results)  ggplot(ceac_out,aes(x=wtp,y=prob_best,group=comparator,col=comparator)) +   geom_line()+   xlab(\"Willingness to Pay\") +   ylab(\"Probability of being cost-effective\")+   theme_bw() +   scale_x_continuous(expand = c(0, 0)) +   ggtitle(\"Cost Effectiveness Acceptability Curve (CEAC)\") +   theme(plot.title = element_text(hjust = 0.5)) ggplot(ceac_out,aes(x=wtp,y=prob_best,group=comparator,col=comparator)) +   geom_step()+   xlab(\"Willingness to Pay\") +   ylab(\"Probability of being cost-effective\")+   theme_bw() +   scale_x_continuous(expand = c(0, 0)) +   ggtitle(\"Cost Effectiveness Acceptability Frontier (CEAF)\")+   theme(plot.title = element_text(hjust = 0.5))"},{"path":"https://jsanchezalv.github.io/RDICE/articles/example_uncertainty.html","id":"evpi","dir":"Articles","previous_headings":"CEAC/CEAF and EVPI","what":"EVPI","title":"Structural and Parametric Uncertainty","text":"Similarly ceac_des, function evpi_des also allows compute EVPI.","code":"evpi_out <-evpi_des(wtp,results)  ggplot(evpi_out,aes(x=wtp,y=evpi)) +   geom_line()+   xlab(\"Willingness to Pay\") +   ylab(\"EVPI\")+   theme_bw() +   scale_x_continuous(expand = c(0, 0)) +   ggtitle(\"Expected Value of Perfect Information (EVPI)\") +   theme(plot.title = element_text(hjust = 0.5))"},{"path":"https://jsanchezalv.github.io/RDICE/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Javier Sanchez Alvarez. Author, maintainer. Gabriel Lemyre. Contributor. Valerie Aponte Ribero. Contributor.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sanchez Alvarez J (2024). RDICE: Discrete Event Simulation Cost-Effectiveness Modelling. R package version 0.97, https://jsanchezalv.github.io/RDICE/.","code":"@Manual{,   title = {RDICE: Discrete Event Simulation for Cost-Effectiveness Modelling},   author = {Javier {Sanchez Alvarez}},   year = {2024},   note = {R package version 0.97},   url = {https://jsanchezalv.github.io/RDICE/}, }"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Discrete Event Simulation for Cost-Effectiveness Modelling","text":"RDICE user-friendly package facilitates use discrete event simulations without resource constraints cost-effectiveness analysis. package supports flexible, practical approach discrete event simulation keeping acceptable performance use parallel computing. current version supports: Discrete event simulation models, Markov/semi-Markov models hybrid models using parallel non-parallel engines Seamlessly integrating data.frames objects model Delayed execution main inputs facilitate readability model Implementation structural parameter uncertainty Helper functions facilitate drawing time events use hazard ratios Performing cost-effectiveness uncertainty analysis recommended user checks vignettes, first simple Sick-Sicker-Dead model complex model early breast cancer. markov example shows run cohort Markov model using modeling framework. Similarly, simulation based Markov model run. Structural parametric uncertainty explored corresponding vignette. IPD vignette shows RDICE can used individual patient data available.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Discrete Event Simulation for Cost-Effectiveness Modelling","text":"look package home site details documentation specific tutorials. details code, check Github repository.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Discrete Event Simulation for Cost-Effectiveness Modelling","text":"RDICE can installed directly repo via","code":"# install.packages(\"devtools\") devtools::install_github(\"jsanchezalv/RDICE\", ref=\"main\")"},{"path":"https://jsanchezalv.github.io/RDICE/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Discrete Event Simulation for Cost-Effectiveness Modelling","text":"use RDICE, please contact authors date appropiate citation.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_item.html","id":null,"dir":"Reference","previous_headings":"","what":"Defining parameters that may be used in model calculations — add_item","title":"Defining parameters that may be used in model calculations — add_item","text":"Defining parameters may used model calculations","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_item.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defining parameters that may be used in model calculations — add_item","text":"","code":"add_item(.data = NULL, ...)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_item.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defining parameters that may be used in model calculations — add_item","text":".data Existing data ... Items define simulation","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_item.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Defining parameters that may be used in model calculations — add_item","text":"list items","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_item.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Defining parameters that may be used in model calculations — add_item","text":"functions add/modify events/inputs use lists. Whenever several inputs/events added modified, recommended group within one function, reduces computation cost. rather use two add_item list one element, better group single add_item list two elements. Whenever function directly implemented must evaluated later object name attached (e.g., pick_val_v), implemented first add_item() (empty content) avoid confusing .data argument, wrapping function within substitute()","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_item.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Defining parameters that may be used in model calculations — add_item","text":"","code":"if (FALSE) { # \\dontrun{ add_item(fl.idfs = 0) add_item(util_idfs = if(psa_bool){rnorm(1,0.8,0.2)} else{0.8}, util.mbc = 0.6, cost_idfs = 2500) common_inputs <- add_item() %>% add_item(pick_val_v(   base      = l_statics[[\"base\"]],   psa       = pick_psa(     l_statics[[\"function\"]],     l_statics[[\"n\"]],     l_statics[[\"a\"]],     l_statics[[\"b\"]]   ),   sens      = l_statics[[sens_name_used]],   psa_ind   = psa_bool,   sens_ind  = sensitivity_bool,   indicator = indicators_statics,   names_out = l_statics[[\"parameter_name\"]] ) ) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_reactevt.html","id":null,"dir":"Reference","previous_headings":"","what":"Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event — add_reactevt","title":"Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event — add_reactevt","text":"Define modifications events, costs, utilities, items affected occurrence event","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_reactevt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event — add_reactevt","text":"","code":"add_reactevt(.data = NULL, name_evt, input)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_reactevt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event — add_reactevt","text":".data Existing data event reactions name_evt Name event reactions defined. input Expressions define happens event, using functions defined Details section","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_reactevt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event — add_reactevt","text":"series objects can used context help define event reactions. following functions may used define event reactions within add_reactevt() function: modify_item() | Adds & Modifies items/flags/variables future events (consider sequential) modify_item_seq() | Adds & Modifies items/flags/variables future events sequential manner new_event() | Adds events vector events patient modify_event() | Modifies existing events changing time Apart items defined add_item(), can also use standard variables always defined within simulation: curtime | Current event time (numeric) prevtime | Time previous event (numeric) cur_evtlist | Named vector events yet happen patient (named numeric vector) evt | Current event processed (character) | Patient iterated (character) simulation | Simulation iterated (numeric) model run curtime set Inf, event terminates model modify curtime set Inf. user can use extract_from_reactions function output obtain data.frame relationships defined reactions model.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_reactevt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event — add_reactevt","text":"","code":"if (FALSE) { # \\dontrun{ add_reactevt(name_evt = \"start\",input = {}) add_reactevt(name_evt = \"idfs\",input = {modify_item(list(\"fl.idfs\"= 0))}) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_tte.html","id":null,"dir":"Reference","previous_headings":"","what":"Define events and the initial event time — add_tte","title":"Define events and the initial event time — add_tte","text":"Define events initial event time","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_tte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define events and the initial event time — add_tte","text":"","code":"add_tte(.data = NULL, arm, evts, other_inp = NULL, input)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_tte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define events and the initial event time — add_tte","text":".data Existing data initial event times arm intervention events initial event times defined evts vector names events other_inp vector input variables saved simulation input definition initial event times events listed evts argument","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_tte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define events and the initial event time — add_tte","text":"list initial events event times","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_tte.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define events and the initial event time — add_tte","text":"Events need separately defined intervention. event defined list, user needs add reaction event using add_reactevt() function determine calculations happen event.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/add_tte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define events and the initial event time — add_tte","text":"","code":"if (FALSE) { # \\dontrun{ add_tte(arm=\"int\",evts = c(\"start\",\"ttot\",\"idfs\",\"os\"), input={ start <- 0 idfs <- draw_tte(1,'lnorm',coef1=2, coef2=0.5) ttot <- min(draw_tte(1,'lnorm',coef1=1, coef2=4),idfs) os <- draw_tte(1,'lnorm',coef1=0.8, coef2=0.2) }) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/ceac_des.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result — ceac_des","title":"Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result — ceac_des","text":"Calculate cost-effectiveness acceptability curve (CEAC) DES model PSA result","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/ceac_des.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result — ceac_des","text":"","code":"ceac_des(wtp, results, interventions = NULL, sensitivity_used = 1)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/ceac_des.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result — ceac_des","text":"wtp Vector length >=1 willingness pay results list object returned run_sim() interventions character vector names interventions used analysis sensitivity_used Integer signaling sensitivity analysis use","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/ceac_des.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result — ceac_des","text":"data frame CEAC results","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/ceac_des.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result — ceac_des","text":"","code":"if (FALSE) { # \\dontrun{ ceac_des(seq(from=10000,to=500000,by=10000),results) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_dirichlet.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate conditional dirichlet values — cond_dirichlet","title":"Calculate conditional dirichlet values — cond_dirichlet","text":"Calculate conditional dirichlet values","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_dirichlet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate conditional dirichlet values — cond_dirichlet","text":"","code":"cond_dirichlet(alpha, i, xi, full_output = FALSE)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_dirichlet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate conditional dirichlet values — cond_dirichlet","text":"alpha mean vector index known parameter (1-based index) xi known value -th parameter (>0) full_output boolean indicating whether return full list parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_dirichlet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate conditional dirichlet values — cond_dirichlet","text":"List length 2, one new mu covariance parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_dirichlet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate conditional dirichlet values — cond_dirichlet","text":"Function compute conditional dirichlet values","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_dirichlet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate conditional dirichlet values — cond_dirichlet","text":"","code":"alpha <- c(2, 3, 4) i <- 2  # Index of the known parameter xi <- 0.5  # Known value of the second parameter  # Compute the conditional alpha parameters with full output cond_dirichlet(alpha, i, xi, full_output = TRUE) #> [1] 0.1666667 0.5000000 0.3333333"},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_mvn.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate conditional multivariate normal values — cond_mvn","title":"Calculate conditional multivariate normal values — cond_mvn","text":"Calculate conditional multivariate normal values","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_mvn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate conditional multivariate normal values — cond_mvn","text":"","code":"cond_mvn(mu, Sigma, i, xi, full_output = FALSE)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_mvn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate conditional multivariate normal values — cond_mvn","text":"mu mean vector Sigma covariance matrix index known parameter (1-based index) xi known value -th parameter full_output boolean indicating whether return full list parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_mvn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate conditional multivariate normal values — cond_mvn","text":"List length 2, one new mu covariance parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_mvn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate conditional multivariate normal values — cond_mvn","text":"Function compute conditional multivariate normal values","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/cond_mvn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate conditional multivariate normal values — cond_mvn","text":"","code":"mu <- c(1, 2, 3) Sigma <- matrix(c(0.2, 0.05, 0.1,                    0.05, 0.3, 0.05,                    0.1, 0.05, 0.4), nrow = 3)  i <- 1:2  # Index of the known parameter xi <- c(1.2,2.3)  # Known value of the first parameter  cond_mvn(mu, Sigma, i, xi,full_output = TRUE) #> $mean #> [1] 1.200000 2.300000 3.121739 #>  #> $covariance #>      [,1] [,2]      [,3] #> [1,]    0    0 0.0000000 #> [2,]    0    0 0.0000000 #> [3,]    0    0 0.3478261 #>"},{"path":"https://jsanchezalv.github.io/RDICE/reference/create_indicators.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis — create_indicators","title":"Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis — create_indicators","text":"Creates vector indicators (0 1) sensitivity/DSA analysis","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/create_indicators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis — create_indicators","text":"","code":"create_indicators(sens, n_sensitivity, elem, n_elem_before = 0)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/create_indicators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis — create_indicators","text":"sens current analysis iterator n_sensitivity total number analyses run elem vector 0s 1s elements iterate (1 = parameter included scenario/DSA) n_elem_before Sum 1s (# parameters included scenario/DSA) go elem","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/create_indicators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis — create_indicators","text":"Numeric vector composed 0 1, value 1 used pick_val_v pick corresponding index sens argument","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/create_indicators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis — create_indicators","text":"n_elem_before used several indicators want used (e.g., patient level common level inputs) facilitating readibility code","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/create_indicators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis — create_indicators","text":"","code":"if (FALSE) { # \\dontrun{ create_indicators(10,20,c(1,1,1,1)) create_indicators(7,20,c(1,0,0,1,1,1,0,0,1,1),2) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Cycle discounting — disc_cycle","title":"Cycle discounting — disc_cycle","text":"Cycle discounting","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cycle discounting — disc_cycle","text":"","code":"disc_cycle(   lcldr = 0.035,   lclprvtime = 0,   cyclelength,   lclcurtime,   lclval,   starttime = 0 )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cycle discounting — disc_cycle","text":"lcldr discount rate lclprvtime time previous event simulation cyclelength cycle length lclcurtime time current event simulation lclval  value discounted starttime start time accrual cycle costs (0)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cycle discounting — disc_cycle","text":"Double based cycle discounting","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cycle discounting — disc_cycle","text":"","code":"if (FALSE) { # \\dontrun{ disc_cycle(lcldr=0.035, lclprvtime=0, cyclelength=1/12, lclcurtime=2, lclval=500,starttime=0) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle_v.html","id":null,"dir":"Reference","previous_headings":"","what":"Cycle discounting for vectors — disc_cycle_v","title":"Cycle discounting for vectors — disc_cycle_v","text":"Cycle discounting vectors","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle_v.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cycle discounting for vectors — disc_cycle_v","text":"","code":"disc_cycle_v(   lcldr = 0.035,   lclprvtime = 0,   cyclelength,   lclcurtime,   lclval,   starttime = 0 )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle_v.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cycle discounting for vectors — disc_cycle_v","text":"lcldr discount rate lclprvtime time previous event simulation cyclelength cycle length lclcurtime time current event simulation lclval  value discounted starttime start time accrual cycle costs (0)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle_v.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cycle discounting for vectors — disc_cycle_v","text":"Double based cycle discounting","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_cycle_v.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cycle discounting for vectors — disc_cycle_v","text":"","code":"if (FALSE) { # \\dontrun{ disc_cycle_v(lcldr=0.035, lclprvtime=0, cyclelength=1/12, lclcurtime=2, lclval=500,starttime=0) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate instantaneous discounted costs or qalys — disc_instant","title":"Calculate instantaneous discounted costs or qalys — disc_instant","text":"Calculate instantaneous discounted costs qalys","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate instantaneous discounted costs or qalys — disc_instant","text":"","code":"disc_instant(lcldr = 0.035, lclcurtime, lclval)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate instantaneous discounted costs or qalys — disc_instant","text":"lcldr discount rate lclcurtime time current event simulation lclval value discounted","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate instantaneous discounted costs or qalys — disc_instant","text":"Double based discrete time discounting","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate instantaneous discounted costs or qalys — disc_instant","text":"","code":"if (FALSE) { # \\dontrun{ disc_instant(lcldr=0.035, lclcurtime=3, lclval=2500) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant_v.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate instantaneous discounted costs or qalys for vectors — disc_instant_v","title":"Calculate instantaneous discounted costs or qalys for vectors — disc_instant_v","text":"Calculate instantaneous discounted costs qalys vectors","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant_v.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate instantaneous discounted costs or qalys for vectors — disc_instant_v","text":"","code":"disc_instant_v(lcldr = 0.035, lclcurtime, lclval)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant_v.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate instantaneous discounted costs or qalys for vectors — disc_instant_v","text":"lcldr discount rate lclcurtime time current event simulation lclval value discounted","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant_v.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate instantaneous discounted costs or qalys for vectors — disc_instant_v","text":"Double based discrete time discounting","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_instant_v.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate instantaneous discounted costs or qalys for vectors — disc_instant_v","text":"","code":"if (FALSE) { # \\dontrun{ disc_instant_v(lcldr=0.035, lclcurtime=3, lclval=2500) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate discounted costs and qalys between events — disc_ongoing","title":"Calculate discounted costs and qalys between events — disc_ongoing","text":"Calculate discounted costs qalys events","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate discounted costs and qalys between events — disc_ongoing","text":"","code":"disc_ongoing(lcldr = 0.035, lclprvtime, lclcurtime, lclval)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate discounted costs and qalys between events — disc_ongoing","text":"lcldr discount rate lclprvtime time previous event simulation lclcurtime time current event simulation lclval value discounted","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate discounted costs and qalys between events — disc_ongoing","text":"Double based continuous time discounting","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate discounted costs and qalys between events — disc_ongoing","text":"","code":"if (FALSE) { # \\dontrun{ disc_ongoing(lcldr=0.035,lclprvtime=0.5, lclcurtime=3, lclval=2500) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing_v.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate discounted costs and qalys between events for vectors — disc_ongoing_v","title":"Calculate discounted costs and qalys between events for vectors — disc_ongoing_v","text":"Calculate discounted costs qalys events vectors","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing_v.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate discounted costs and qalys between events for vectors — disc_ongoing_v","text":"","code":"disc_ongoing_v(lcldr = 0.035, lclprvtime, lclcurtime, lclval)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing_v.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate discounted costs and qalys between events for vectors — disc_ongoing_v","text":"lcldr discount rate lclprvtime time previous event simulation lclcurtime time current event simulation lclval value discounted","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing_v.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate discounted costs and qalys between events for vectors — disc_ongoing_v","text":"Double based continuous time discounting","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/disc_ongoing_v.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate discounted costs and qalys between events for vectors — disc_ongoing_v","text":"","code":"if (FALSE) { # \\dontrun{ disc_ongoing_v(lcldr=0.035,lclprvtime=0.5, lclcurtime=3, lclval=2500) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/draw_tte.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw a time to event from a list of parametric survival functions — draw_tte","title":"Draw a time to event from a list of parametric survival functions — draw_tte","text":"Draw time event list parametric survival functions","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/draw_tte.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw a time to event from a list of parametric survival functions — draw_tte","text":"","code":"draw_tte(   n_chosen,   dist,   coef1 = NULL,   coef2 = NULL,   coef3 = NULL,   ...,   beta_tx = 1,   seed = NULL )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/draw_tte.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw a time to event from a list of parametric survival functions — draw_tte","text":"n_chosen number observations drawn dist distribution; takes values 'lnorm','norm','mvnorm','weibullPH','weibull','llogis','gompertz','gengamma','gamma','exp','beta','poisgamma' coef1 First coefficient distribution, defined coef() output flexsurvreg object (rate \"rpoisgamma\") coef2 Second coefficient distribution, defined coef() output flexsurvreg object (theta \"rpoisgamma\") coef3 Third coefficient distribution, defined coef() output flexsurvreg object (used \"rpoisgamma\") ... Additional arguments used specific distribution (e.g., return_ind_rate dist = \"poisgamma\") beta_tx Parameter natural scale applied addition scale/rate coefficient -e.g., HR used exponential- (used \"rpoisgamma\" \"beta\") seed integer used set seed draw.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/draw_tte.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw a time to event from a list of parametric survival functions — draw_tte","text":"vector time event estimates given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/draw_tte.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw a time to event from a list of parametric survival functions — draw_tte","text":"arguments relevant function can called directly","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/draw_tte.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw a time to event from a list of parametric survival functions — draw_tte","text":"","code":"draw_tte(n_chosen=1,dist='exp',coef1=1,beta_tx=1) #> [1] 0.8724054 draw_tte(n_chosen=10,\"poisgamma\",coef1=1,coef2=1,obs_time=1,return_ind_rate=FALSE) #> [[1]] #> numeric(0) #>  #> [[2]] #> numeric(0) #>  #> [[3]] #> [1] 0.4057406 #>  #> [[4]] #> [1] 0.0201923 0.5948167 0.9523487 0.9591618 #>  #> [[5]] #> numeric(0) #>  #> [[6]] #> [1] 0.4376726 0.4468282 #>  #> [[7]] #> [1] 0.06426290 0.08436041 0.16090589 0.16731367 0.20930524 #>  #> [[8]] #> numeric(0) #>  #> [[9]] #> [1] 0.1185713 #>  #> [[10]] #> numeric(0) #>"},{"path":"https://jsanchezalv.github.io/RDICE/reference/evpi_des.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result — evpi_des","title":"Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result — evpi_des","text":"Calculate Expected Value Perfect Information (EVPI) DES model PSA result","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/evpi_des.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result — evpi_des","text":"","code":"evpi_des(wtp, results, interventions = NULL, sensitivity_used = 1)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/evpi_des.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result — evpi_des","text":"wtp Vector length >=1 willingness pay results list object returned run_sim() interventions character vector names interventions used analysis sensitivity_used Integer signaling sensitivity analysis use","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/evpi_des.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result — evpi_des","text":"data frame EVPI results","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/evpi_des.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result — evpi_des","text":"","code":"if (FALSE) { # \\dontrun{ evpi_des(seq(from=10000,to=500000,by=10000),results) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_elements_from_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event — extract_elements_from_list","title":"Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event — extract_elements_from_list","text":"Extracts items events looking modify_item, modify_item_seq, modify_event new_event","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_elements_from_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event — extract_elements_from_list","text":"","code":"extract_elements_from_list(node, conditional_flag = FALSE)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_elements_from_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event — extract_elements_from_list","text":"node Relevant node within nested AST list conditional_flag Boolean whether statement contained within conditional statement","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_elements_from_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event — extract_elements_from_list","text":"data.frame relevant item/event, event assigned, whether contained within conditional statement expr <- substitute(<- sum(5+7)modify_item(list(afsa=ifelse(TRUE,\"asda\",NULL)))modify_item_seq(list(o_other_q_gold1 = (gold == 1)  utility  else  0 ,o_other_q_gold2 = (gold == 2)  utility  else  0 ,o_other_q_gold3 = (gold == 3)  utility  else  0 ,o_other_q_gold4 = (gold == 4)  utility  else  0 ,o_other_q_on_dup = (on_dup)  utility  else  0 ))(==1) modify_item(list(=list(6+b)))modify_event(list(e_exn = curtime + 14 / days_in_year + qexp(rnd_exn, r_exn)))  else modify_event(list(e_exn = curtime + 14 / days_in_year + qexp(rnd_exn, r_exn))) (>6) modify_item(list(=8))(sel_resp_incl == 1 & on_dup == 1) modify_event(list(e_response = curtime, z = 6))) <- ast_as_list(expr) results <- extract_elements_from_list()","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_from_reactions.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract all items and events and their interactions from the event reactions list — extract_from_reactions","title":"Extract all items and events and their interactions from the event reactions list — extract_from_reactions","text":"Extract items events interactions event reactions list","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_from_reactions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract all items and events and their interactions from the event reactions list — extract_from_reactions","text":"","code":"extract_from_reactions(reactions)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_from_reactions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract all items and events and their interactions from the event reactions list — extract_from_reactions","text":"reactions list generated add_reactevt","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_from_reactions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract all items and events and their interactions from the event reactions list — extract_from_reactions","text":"data.frame relevant item/event, event assigned, whether contained within conditional statement","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_from_reactions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract all items and events and their interactions from the event reactions list — extract_from_reactions","text":"","code":"a <- add_reactevt(name_evt=\"example\",    input={       modify_item(list(w=5))    })      extract_from_reactions(a) #>      event   name   type conditional_flag definition #>     <char> <char> <char>           <lgcl>     <char> #> 1: example      w   item            FALSE          5"},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_psa_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract PSA results from a treatment — extract_psa_result","title":"Extract PSA results from a treatment — extract_psa_result","text":"Extract PSA results treatment","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_psa_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract PSA results from a treatment — extract_psa_result","text":"","code":"extract_psa_result(x, element)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_psa_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract PSA results from a treatment — extract_psa_result","text":"x output_sim data frame list object returned run_sim() element Variable PSA results extracted (single string)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_psa_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract PSA results from a treatment — extract_psa_result","text":"dataframe PSA results specified intervention","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/extract_psa_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract PSA results from a treatment — extract_psa_result","text":"","code":"if (FALSE) { # \\dontrun{ extract_psa_result(results[[1]],\"total_costs\") } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/luck_adj.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform luck adjustment — luck_adj","title":"Perform luck adjustment — luck_adj","text":"Perform luck adjustment","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/luck_adj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform luck adjustment — luck_adj","text":"","code":"luck_adj(prevsurv, cursurv, luck, condq = TRUE)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/luck_adj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform luck adjustment — luck_adj","text":"prevsurv Value previous survival cursurv Value current survival luck Luck used adjusted (number 0 1) condq Conditional quantile approach standard approach","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/luck_adj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform luck adjustment — luck_adj","text":"Adjusted luck number 0 1","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/luck_adj.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform luck adjustment — luck_adj","text":"function performs luck adjustment automatically user, returning adjusted luck number. Luck interpreted fashion standard R (higher luck, higher time event). Note TTE predicted using conditional quantile function (e.g., conditional gompertz, conditional quantile weibull...) prevsurv cursurv unconditional survival using \"previous\" parametrization previous time presurv current time cursurv. distributions, presurv survival current time using previous parametrization, cursurv survival current time using current parametrization. Note advantage conditional quantile function need new parametrization update luck, makes approach computationally efficient. function can also work vectors, allow update multiple lucks single approach, can preserve names","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/luck_adj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform luck adjustment — luck_adj","text":"","code":"luck_adj(prevsurv = 0.8,  cursurv = 0.7,  luck = 0.5,  condq = TRUE) #> [1] 0.4285714   luck_adj(prevsurv = c(1,0.8,0.7),  cursurv = c(0.7,0.6,0.5),  luck = setNames(c(0.5,0.6,0.7),c(\"A\",\"B\",\"C\")),  condq = TRUE) #>         A         B         C  #> 0.2857143 0.4666667 0.5800000    luck_adj(prevsurv = 0.8,  cursurv = 0.7,  luck = 0.5,  condq = FALSE) #different results #> [1] 0.5625  #Unconditional approach, timepoint of change is 25, # parameter goes from 0.02 at time 10 to 0.025 to 0.015 at time 25, #  starting luck is 0.37 new_luck <- luck_adj(prevsurv = 1 - pweibull(q=10,3,1/0.02),  cursurv = 1 - pweibull(q=10,3,1/0.025),  luck = 0.37,  condq = FALSE) #time 10 change   new_luck <- luck_adj(prevsurv = 1 - pweibull(q=25,3,1/0.025),  cursurv = 1 - pweibull(q=25,3,1/0.015),  luck = new_luck,  condq = FALSE) #time 25 change   qweibull(new_luck, 3, 1/0.015) #final TTE  #> [1] 43.52338  #Conditional quantile approach  new_luck <- luck_adj(prevsurv = 1-pweibull(q=0,3,1/0.02),                       cursurv = 1- pweibull(q=10,3,1/0.02),                       luck = 0.37,                       condq = TRUE) #time 10 change, previous time is 0 so prevsurv will be 1  new_luck <- luck_adj(prevsurv = 1-pweibull(q=10,3,1/0.025),                       cursurv = 1- pweibull(q=25,3,1/0.025),                       luck = new_luck,                       condq = TRUE) #time 25 change  qcond_weibull(rnd = new_luck,                      shape = 3,                      scale = 1/0.015,                      lower_bound = 25) + 25 #final TTE #> [1] 43.52338"},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify the time of existing events — modify_event","title":"Modify the time of existing events — modify_event","text":"Modify time existing events","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify the time of existing events — modify_event","text":"","code":"modify_event(evt, create_if_null = TRUE)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify the time of existing events — modify_event","text":"evt list events times create_if_null boolean. TRUE, create non-existing events chosen time event. FALSE, ignore .","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_event.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modify the time of existing events — modify_event","text":"functions add/modify events/inputs use lists. Whenever several inputs/events added modified, recommended group within one function, reduces computation cost. rather use two modify_event list one element, better group single modify_event list two elements. function evaluate sequentially.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify the time of existing events — modify_event","text":"","code":"if (FALSE) { # \\dontrun{ modify_event(list(\"os\"=40, \"ttot\"=curtime+0.0001)) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify the value of existing items — modify_item","title":"Modify the value of existing items — modify_item","text":"Modify value existing items","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify the value of existing items — modify_item","text":"","code":"modify_item(list_item)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify the value of existing items — modify_item","text":"list_item list items values expressions","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modify the value of existing items — modify_item","text":"functions add/modify events/inputs use lists. Whenever several inputs/events added modified, recommended group within one function, reduces computation cost. rather use two modify_item list one element, better group single modify_item list two elements. Costs utilities can modified using construction type_name_category, type either \"qaly\" \"cost\", name name (e.g., \"default\") category category used (e.g., \"instant\"), one pass cost_default_instant modify cost. overwrite value defined corresponding cost/utility section.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify the value of existing items — modify_item","text":"","code":"if (FALSE) { # \\dontrun{ modify_item(list(cost.idfs = 500, cost.tx = cost.tx + 4000)) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify the value of existing items — modify_item_seq","title":"Modify the value of existing items — modify_item_seq","text":"Modify value existing items","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify the value of existing items — modify_item_seq","text":"","code":"modify_item_seq(...)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify the value of existing items — modify_item_seq","text":"... list items values expressions. evaluated sequentially (one list(= 1, b = +2 ))","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item_seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modify the value of existing items — modify_item_seq","text":"functions add/modify events/inputs use lists. Whenever several inputs/events added modified, recommended group within one function, reduces computation cost. rather use two modify_item list one element, better group single modify_item list two elements. Costs utilities can modified using construction type_name_category, type either \"qaly\" \"cost\", name name (e.g., \"default\") category category used (e.g., \"instant\"), one pass cost_default_instant modify cost. overwrite value defined corresponding cost/utility section. function different modify_item function evaluates sequentially arguments within list passed. implies slower performance relative modify_item, can cleaner convenient certain instances.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/modify_item_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify the value of existing items — modify_item_seq","text":"","code":"if (FALSE) { # \\dontrun{ modify_item_seq(list(cost.idfs = 500, cost.tx = cost.idfs + 4000)) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/new_event.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate new events to be added to existing vector of events — new_event","title":"Generate new events to be added to existing vector of events — new_event","text":"Generate new events added existing vector events","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/new_event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate new events to be added to existing vector of events — new_event","text":"","code":"new_event(evt)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/new_event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate new events to be added to existing vector of events — new_event","text":"evt Event name event time","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/new_event.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate new events to be added to existing vector of events — new_event","text":"functions add/modify events/inputs use lists. Whenever several inputs/events added modified, recommended group within one function, reduces computation cost. rather use two new_event list one element, better group single new_event list two elements.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/new_event.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate new events to be added to existing vector of events — new_event","text":"","code":"if (FALSE) { # \\dontrun{ new_event(list(\"ae\"=5)) new_event(list(\"ae\"=5,\"nat.death\" = 100)) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/pcond_gompertz.html","id":null,"dir":"Reference","previous_headings":"","what":"Survival Probaility function for conditional Gompertz distribution (lower bound only) — pcond_gompertz","title":"Survival Probaility function for conditional Gompertz distribution (lower bound only) — pcond_gompertz","text":"Survival Probaility function conditional Gompertz distribution (lower bound )","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pcond_gompertz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survival Probaility function for conditional Gompertz distribution (lower bound only) — pcond_gompertz","text":"","code":"pcond_gompertz(time = 1, shape, rate, lower_bound = 0)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/pcond_gompertz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Survival Probaility function for conditional Gompertz distribution (lower bound only) — pcond_gompertz","text":"time Vector times shape shape parameter Gompertz distribution, defined coef() output flexsurvreg object rate rate parameter Gompertz distribution, defined coef() output flexsurvreg object lower_bound lower bound conditional distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pcond_gompertz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Survival Probaility function for conditional Gompertz distribution (lower bound only) — pcond_gompertz","text":"Estimate(s) conditional Gompertz distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pcond_gompertz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Survival Probaility function for conditional Gompertz distribution (lower bound only) — pcond_gompertz","text":"","code":"pcond_gompertz(time=1,shape=0.05,rate=0.01,lower_bound = 50) #> [1] 0.1174342"},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_psa.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within pick_val_v. — pick_psa","title":"Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within pick_val_v. — pick_psa","text":"Helper function create list random draws whenever series functions needs called. Can implemented within pick_val_v.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_psa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within pick_val_v. — pick_psa","text":"","code":"pick_psa(f, ...)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_psa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within pick_val_v. — pick_psa","text":"f string vector strings function called, e.g., \"rnorm\" ... parameters passed function (e.g., \"rnorm\", arguments n, mean, sd)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_psa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within pick_val_v. — pick_psa","text":"List length equal f parameters called","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_psa.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within pick_val_v. — pick_psa","text":"function can used pick values PSA within pick_val_v. function ignore NA items within respective parameter (see example ). element f NA (e.g., non PSA input) return NA value feature convenient mixing distributions different number arguments, e.g., rnorm rgengamma. slightly lower individually calling function, makes code easier read transparent","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_psa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within pick_val_v. — pick_psa","text":"","code":"if (FALSE) { # \\dontrun{ params <- list( param=list(\"a\",\"b\"), dist=list(\"rlnorm\",\"rnorm\"), n=list(4,1), a=list(c(1,2,3,4),1), b=list(c(0.5,0.5,0.5,0.5),0.5), dsa_min=list(c(1,2,3,4),2), dsa_max=list(c(1,2,3,4),3) ) pick_psa(params[[\"dist\"]],params[[\"n\"]],params[[\"a\"]],params[[\"b\"]])  #It works with functions that require different number of parameters params <- list(  param=list(\"a\",\"b\",\"c\"),  dist=list(\"rlnorm\",\"rnorm\",\"rgengamma\"),  n=list(4,1,1),  a=list(c(1,2,3,4),1,0),  b=list(c(0.5,0.5,0.5,0.5),0.5,1),  c=list(NA,NA,0.2),  dsa_min=list(c(1,2,3,4),2,1),  dsa_max=list(c(1,2,3,4),3,3) )  pick_psa(params[[\"dist\"]],params[[\"n\"]],params[[\"a\"]],params[[\"b\"]],params[[\"c\"]])  #Can be combined with multiple type of functions and distributions if parameters are well located  params <- list( param=list(\"a\",\"b\",\"c\",\"d\"), dist=list(\"rlnorm\",\"rnorm\",\"rgengamma\",\"draw_tte\"), n=list(4,1,1,1), a=list(c(1,2,3,4),1,0,\"norm\"), b=list(c(0.5,0.5,0.5,0.5),0.5,1,1), c=list(NA,NA,0.2,0.5), c=list(NA,NA,NA,NA), #NA arguments will be ignored dsa_min=list(c(1,2,3,4),2,1,0), dsa_max=list(c(1,2,3,4),3,3,2) )    } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_val_v.html","id":null,"dir":"Reference","previous_headings":"","what":"Select which values should be applied in the corresponding loop for several values (vector or list). — pick_val_v","title":"Select which values should be applied in the corresponding loop for several values (vector or list). — pick_val_v","text":"Select values applied corresponding loop several values (vector list).","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_val_v.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select which values should be applied in the corresponding loop for several values (vector or list). — pick_val_v","text":"","code":"pick_val_v(   base,   psa,   sens,   psa_ind = psa_bool,   sens_ind = sens_bool,   indicator,   indicator_psa = NULL,   names_out = NULL,   indicator_sens_binary = TRUE,   sens_iterator = NULL,   distributions = NULL,   covariances = NULL )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_val_v.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select which values should be applied in the corresponding loop for several values (vector or list). — pick_val_v","text":"base Value PSA/DSA/Scenario psa Value PSA sens Value DSA/Scenario psa_ind Boolean whether PSA active sens_ind Boolean whether Scenario/DSA active indicator Indicator checks whether specific parameter/parameters /active DSA Scenario loop indicator_psa Indicator checks whether specific parameter/parameters /active PSA loop. NULL, assumed vector 1s length equal length(indicator) names_out Names give output list indicator_sens_binary Boolean, TRUE parameters varied fully, FALSE elements parameters may changed sens_iterator Current iterator number DSA/scenario run, e.g., 5 corresponds 5th DSA parameter changed distributions List length equal length base distributions stored covariances List length equal length base variance/covariances stored (relevant multivariate normal used)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_val_v.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select which values should be applied in the corresponding loop for several values (vector or list). — pick_val_v","text":"List used inputs","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_val_v.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select which values should be applied in the corresponding loop for several values (vector or list). — pick_val_v","text":"function can used vectors lists, always return list. Lists used correlated variables introduced make sure selector knows choose among function allows choose using approach full parameters varied, approach subelements parameters can changed","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/pick_val_v.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select which values should be applied in the corresponding loop for several values (vector or list). — pick_val_v","text":"","code":"if (FALSE) { # \\dontrun{ pick_val_v(base = list(0,0),              psa =list(rnorm(1,0,0.1),rnorm(1,0,0.1)),              sens = list(2,3),              psa_ind = FALSE,              sens_ind = TRUE,              indicator=list(1,2),              indicator_sens_binary = FALSE,              sens_iterator = 2,              distributions = list(\"rnorm\",\"rnorm\") )  pick_val_v(base = list(2,3,c(1,2)),              psa =sapply(1:3,                          function(x) eval(call(                            c(\"rnorm\",\"rnorm\",\"mvrnorm\")[[x]],                            1,                            c(2,3,list(c(1,2)))[[x]],                            c(0.1,0.1,list(matrix(c(1,0.1,0.1,1),2,2)))[[x]]                          ))),              sens = list(4,5,c(1.3,2.3)),              psa_ind = FALSE,              sens_ind = TRUE,              indicator=list(1,2,c(3,4)),              names_out=c(\"util\",\"util2\",\"correlated_vector\") ,              indicator_sens_binary = FALSE,              sens_iterator = 4,              distributions = list(\"rnorm\",\"rnorm\",\"mvrnorm\"),              covariances = list(0.1,0.1,matrix(c(1,0.1,0.1,1),2,2)) )   } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qbeta_mse.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw from a beta distribution based on mean and se (quantile) — qbeta_mse","title":"Draw from a beta distribution based on mean and se (quantile) — qbeta_mse","text":"Draw beta distribution based mean se (quantile)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qbeta_mse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw from a beta distribution based on mean and se (quantile) — qbeta_mse","text":"","code":"qbeta_mse(q, mean_v, se)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qbeta_mse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw from a beta distribution based on mean and se (quantile) — qbeta_mse","text":"q Quantiles used mean_v vector mean values se vector standard errors means","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qbeta_mse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw from a beta distribution based on mean and se (quantile) — qbeta_mse","text":"single estimate beta distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qbeta_mse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw from a beta distribution based on mean and se (quantile) — qbeta_mse","text":"","code":"qbeta_mse(q=0.5,mean_v=0.8,se=0.2) #> [1] 0.8671142"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_exp.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional quantile function for exponential distribution — qcond_exp","title":"Conditional quantile function for exponential distribution — qcond_exp","text":"Conditional quantile function exponential distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_exp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional quantile function for exponential distribution — qcond_exp","text":"","code":"qcond_exp(rnd = 0.5, rate)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_exp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional quantile function for exponential distribution — qcond_exp","text":"rnd Vector quantiles rate rate parameter Note taht conditional quantile exponential independent time due constant hazard","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_exp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional quantile function for exponential distribution — qcond_exp","text":"Estimate(s) conditional exponential distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_exp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional quantile function for exponential distribution — qcond_exp","text":"","code":"qcond_exp(rnd = 0.5,rate = 3) #> [1] 0.2310491"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional quantile function for gamma distribution — qcond_gamma","title":"Conditional quantile function for gamma distribution — qcond_gamma","text":"Conditional quantile function gamma distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional quantile function for gamma distribution — qcond_gamma","text":"","code":"qcond_gamma(rnd = 0.5, rate, shape, lower_bound = 0, s_obs)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional quantile function for gamma distribution — qcond_gamma","text":"rnd Vector quantiles rate rate parameter shape shape parameter lower_bound lower bound used (current time) s_obs survival observed lower_bound time, normally defined time 0 1 - pgamma(q = lower_bound, rate, shape) may different parametrization changed previously","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional quantile function for gamma distribution — qcond_gamma","text":"Estimate(s) conditional gamma distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional quantile function for gamma distribution — qcond_gamma","text":"","code":"qcond_gamma(rnd = 0.5, rate = 1.06178, shape = 0.01108,lower_bound = 1, s_obs=0.8) #> [1] 87.94889"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gompertz.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile function for conditional Gompertz distribution (lower bound only) — qcond_gompertz","title":"Quantile function for conditional Gompertz distribution (lower bound only) — qcond_gompertz","text":"Quantile function conditional Gompertz distribution (lower bound )","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gompertz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile function for conditional Gompertz distribution (lower bound only) — qcond_gompertz","text":"","code":"qcond_gompertz(rnd = 0.5, shape, rate, lower_bound = 0)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gompertz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile function for conditional Gompertz distribution (lower bound only) — qcond_gompertz","text":"rnd Vector quantiles shape shape parameter Gompertz distribution, defined coef() output flexsurvreg object rate rate parameter Gompertz distribution, defined coef() output flexsurvreg object lower_bound lower bound conditional distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gompertz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile function for conditional Gompertz distribution (lower bound only) — qcond_gompertz","text":"Estimate(s) conditional Gompertz distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_gompertz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile function for conditional Gompertz distribution (lower bound only) — qcond_gompertz","text":"","code":"qcond_gompertz(rnd=0.5,shape=0.05,rate=0.01,lower_bound = 50) #> [1] 5.007156"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_llogis.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional quantile function for loglogistic distribution — qcond_llogis","title":"Conditional quantile function for loglogistic distribution — qcond_llogis","text":"Conditional quantile function loglogistic distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_llogis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional quantile function for loglogistic distribution — qcond_llogis","text":"","code":"qcond_llogis(rnd = 0.5, shape, scale, lower_bound = 0)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_llogis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional quantile function for loglogistic distribution — qcond_llogis","text":"rnd Vector quantiles shape shape parameter scale scale parameter lower_bound lower bound used (current time)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_llogis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional quantile function for loglogistic distribution — qcond_llogis","text":"Estimate(s) conditional loglogistic distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_llogis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional quantile function for loglogistic distribution — qcond_llogis","text":"","code":"qcond_llogis(rnd = 0.5,shape = 1,scale = 1,lower_bound = 1) #> [1] 2"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_lnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional quantile function for lognormal distribution — qcond_lnorm","title":"Conditional quantile function for lognormal distribution — qcond_lnorm","text":"Conditional quantile function lognormal distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_lnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional quantile function for lognormal distribution — qcond_lnorm","text":"","code":"qcond_lnorm(rnd = 0.5, meanlog, sdlog, lower_bound = 0, s_obs)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_lnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional quantile function for lognormal distribution — qcond_lnorm","text":"rnd Vector quantiles meanlog meanlog parameter sdlog sdlog parameter lower_bound lower bound used (current time) s_obs survival observed lower_bound time, normally defined time 0 1 - plnorm(q = lower_bound, meanlog, sdlog) may different parametrization changed previously","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_lnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional quantile function for lognormal distribution — qcond_lnorm","text":"Estimate(s) conditional lognormal distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_lnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional quantile function for lognormal distribution — qcond_lnorm","text":"","code":"qcond_lnorm(rnd = 0.5, meanlog = 1,sdlog = 1,lower_bound = 1, s_obs=0.8) #> [1] 2.502045"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional quantile function for normal distribution — qcond_norm","title":"Conditional quantile function for normal distribution — qcond_norm","text":"Conditional quantile function normal distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional quantile function for normal distribution — qcond_norm","text":"","code":"qcond_norm(rnd = 0.5, mean, sd, lower_bound = 0, s_obs)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional quantile function for normal distribution — qcond_norm","text":"rnd Vector quantiles mean mean parameter sd sd parameter lower_bound lower bound used (current time) s_obs survival observed lower_bound time, normally defined time 0 1 - pnorm(q = lower_bound, mean, sd) may different parametrization changed previously","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional quantile function for normal distribution — qcond_norm","text":"Estimate(s) conditional normal distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional quantile function for normal distribution — qcond_norm","text":"","code":"qcond_norm(rnd = 0.5, mean = 1,sd = 1,lower_bound = 1, s_obs=0.8) #> [1] 0.2533471"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_weibull.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional quantile function for weibull distribution — qcond_weibull","title":"Conditional quantile function for weibull distribution — qcond_weibull","text":"Conditional quantile function weibull distribution","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_weibull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional quantile function for weibull distribution — qcond_weibull","text":"","code":"qcond_weibull(rnd = 0.5, shape, scale, lower_bound = 0)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_weibull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional quantile function for weibull distribution — qcond_weibull","text":"rnd Vector quantiles shape shape parameter R stats package weibull scale scale parameter R stats package weibull lower_bound lower bound used (current time)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_weibull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional quantile function for weibull distribution — qcond_weibull","text":"Estimate(s) conditional weibull distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/qcond_weibull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional quantile function for weibull distribution — qcond_weibull","text":"","code":"qcond_weibull(rnd = 0.5,shape = 3,scale = 66.66,lower_bound = 50) #> [1] 19.12624"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rbeta_mse.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw from a beta distribution based on mean and se — rbeta_mse","title":"Draw from a beta distribution based on mean and se — rbeta_mse","text":"Draw beta distribution based mean se","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rbeta_mse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw from a beta distribution based on mean and se — rbeta_mse","text":"","code":"rbeta_mse(n = 1, mean_v, se, seed = NULL)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rbeta_mse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw from a beta distribution based on mean and se — rbeta_mse","text":"n Number draws (must >= 1) mean_v vector mean values se vector standard errors means seed integer used set seed draw.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rbeta_mse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw from a beta distribution based on mean and se — rbeta_mse","text":"single estimate beta distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rbeta_mse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw from a beta distribution based on mean and se — rbeta_mse","text":"","code":"rbeta_mse(n=1,mean_v=0.8,se=0.2) #> [1] 0.9792293"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw from a conditional Gompertz distribution (lower bound only) — rcond_gompertz","title":"Draw from a conditional Gompertz distribution (lower bound only) — rcond_gompertz","text":"Draw conditional Gompertz distribution (lower bound )","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw from a conditional Gompertz distribution (lower bound only) — rcond_gompertz","text":"","code":"rcond_gompertz(n = 1, shape, rate, lower_bound = 0, seed = NULL)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw from a conditional Gompertz distribution (lower bound only) — rcond_gompertz","text":"n number observations drawn shape shape parameter Gompertz distribution, defined coef() output flexsurvreg object rate rate parameter Gompertz distribution, defined coef() output flexsurvreg object lower_bound lower bound conditional distribution seed integer used set seed draw.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw from a conditional Gompertz distribution (lower bound only) — rcond_gompertz","text":"Estimate(s) conditional Gompertz distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw from a conditional Gompertz distribution (lower bound only) — rcond_gompertz","text":"","code":"rcond_gompertz(1,shape=0.05,rate=0.01,lower_bound = 50) #> [1] 4.670301"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz_lu.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw from a Conditional Gompertz distribution (lower and upper bound) — rcond_gompertz_lu","title":"Draw from a Conditional Gompertz distribution (lower and upper bound) — rcond_gompertz_lu","text":"Draw Conditional Gompertz distribution (lower upper bound)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz_lu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw from a Conditional Gompertz distribution (lower and upper bound) — rcond_gompertz_lu","text":"","code":"rcond_gompertz_lu(   n,   shape,   rate,   lower_bound = 0,   upper_bound = Inf,   seed = NULL )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz_lu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw from a Conditional Gompertz distribution (lower and upper bound) — rcond_gompertz_lu","text":"n number observations drawn shape shape parameter Gompertz distribution, defined coef() output flexsurvreg object rate rate parameter Gompertz distribution, defined coef() output flexsurvreg object lower_bound lower bound conditional distribution upper_bound upper bound conditional distribution seed integer used set seed draw.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz_lu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw from a Conditional Gompertz distribution (lower and upper bound) — rcond_gompertz_lu","text":"Estimate(s) Conditional Gompertz distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rcond_gompertz_lu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw from a Conditional Gompertz distribution (lower and upper bound) — rcond_gompertz_lu","text":"","code":"rcond_gompertz_lu(1,shape=0.05,rate=0.01,lower_bound = 50) #> [1] 9.296178"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet — rdirichlet","title":"Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet — rdirichlet","text":"Draw dirichlet distribution based number counts transition. Adapted brms::rdirichlet","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet — rdirichlet","text":"","code":"rdirichlet(n = 1, alpha, seed = NULL)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet — rdirichlet","text":"n Number draws (must >= 1). n>1, return list matrices. alpha matrix alphas (transition counts) seed integer used set seed draw.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet — rdirichlet","text":"transition matrix. n>1, return list matrices.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet — rdirichlet","text":"","code":"rdirichlet(n=1,alpha= matrix(c(1251, 0, 350, 731),2,2)) #>           [,1]      [,2] #> [1,] 0.7977959 0.2022041 #> [2,] 0.0000000 1.0000000 rdirichlet(n=2,alpha= matrix(c(1251, 0, 350, 731),2,2)) #> [[1]] #>           [,1]      [,2] #> [1,] 0.7743144 0.2256856 #> [2,] 0.0000000 1.0000000 #>  #> [[2]] #>           [,1]      [,2] #> [1,] 0.7663271 0.2336729 #> [2,] 0.0000000 1.0000000 #>"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw from a dirichlet distribution based on mean transition probabilities and standard errors — rdirichlet_prob","title":"Draw from a dirichlet distribution based on mean transition probabilities and standard errors — rdirichlet_prob","text":"Draw dirichlet distribution based mean transition probabilities standard errors","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw from a dirichlet distribution based on mean transition probabilities and standard errors — rdirichlet_prob","text":"","code":"rdirichlet_prob(n = 1, alpha, se, seed = NULL)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw from a dirichlet distribution based on mean transition probabilities and standard errors — rdirichlet_prob","text":"n Number draws (must >= 1). n>1, return list matrices. alpha matrix transition probabilities se matrix standard errors seed integer used set seed draw.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw from a dirichlet distribution based on mean transition probabilities and standard errors — rdirichlet_prob","text":"transition matrix. n>1, return list matrices.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rdirichlet_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw from a dirichlet distribution based on mean transition probabilities and standard errors — rdirichlet_prob","text":"","code":"rdirichlet_prob(n=1,alpha= matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7),3,3), se=matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7)/10,3,3)) #>           [,1]       [,2]      [,3] #> [1,] 0.8011909 0.08974514 0.1090640 #> [2,] 0.2261695 0.63451615 0.1393143 #> [3,] 0.0000000 0.25946852 0.7405315  rdirichlet_prob(n=2,alpha= matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7),3,3), se=matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7)/10,3,3)) #> [[1]] #>           [,1]       [,2]       [,3] #> [1,] 0.8223314 0.08177737 0.09589119 #> [2,] 0.2570358 0.52599816 0.21696602 #> [3,] 0.0000000 0.22429024 0.77570976 #>  #> [[2]] #>           [,1]      [,2]      [,3] #> [1,] 0.7713650 0.1109391 0.1176960 #> [2,] 0.2653091 0.5888799 0.1458111 #> [3,] 0.0000000 0.2326174 0.7673826 #>"},{"path":"https://jsanchezalv.github.io/RDICE/reference/replicate_profiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Replicate profiles data.frame — replicate_profiles","title":"Replicate profiles data.frame — replicate_profiles","text":"Replicate profiles data.frame","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/replicate_profiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replicate profiles data.frame — replicate_profiles","text":"","code":"replicate_profiles(   profiles,   replications,   probabilities = NULL,   replacement = TRUE,   seed_used = NULL )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/replicate_profiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replicate profiles data.frame — replicate_profiles","text":"profiles data.frame profiles replications integer, final number observations probabilities vector probabilities length number rows profiles. need add 1 (reweighted) replacement Boolean whether replacement used seed_used Integer seed used consistent results","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/replicate_profiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replicate profiles data.frame — replicate_profiles","text":"Resampled data.frame profiles","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/replicate_profiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replicate profiles data.frame — replicate_profiles","text":"","code":"if (FALSE) { # \\dontrun{ replicate_profiles(profiles=data.frame(id=1:100,age=rnorm(100,60,5)), replications=200,probabilities=rep(1,100)) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rgamma_mse.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw from a gamma distribution based on mean and se — rgamma_mse","title":"Draw from a gamma distribution based on mean and se — rgamma_mse","text":"Draw gamma distribution based mean se","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rgamma_mse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw from a gamma distribution based on mean and se — rgamma_mse","text":"","code":"rgamma_mse(n = 1, mean_v, se, seed = NULL)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rgamma_mse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw from a gamma distribution based on mean and se — rgamma_mse","text":"n Number draws (must >= 1) mean_v vector mean values se vector standard errors means seed integer used set seed draw.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rgamma_mse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw from a gamma distribution based on mean and se — rgamma_mse","text":"single estimate gamma distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rgamma_mse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw from a gamma distribution based on mean and se — rgamma_mse","text":"","code":"rgamma_mse(n=1,mean_v=0.8,se=0.2) #> [1] 1.167139"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rpoisgamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process — rpoisgamma","title":"Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process — rpoisgamma","text":"Draw time event (tte) Poisson Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rpoisgamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process — rpoisgamma","text":"","code":"rpoisgamma(   n,   rate,   theta = NULL,   obs_time = 1,   t_reps,   seed = NULL,   return_ind_rate = FALSE,   return_df = FALSE )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/rpoisgamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process — rpoisgamma","text":"n number observations drawn rate rate event (terms events per observation-time) theta Optional.  omitted, function simulates times Poisson process. Represents shape gamma mixture distribution. Estimated reported theta negative binomial regression analyses r. obs_time period events observable t_reps Optional. Number TBEs generated capture events within observation window. omitted, function sets t_reps 99.99th quantile Poisson (theta provided) negative binomial (theta provided). Thus, risk missing possible events observation window 0.01%. seed integer used set seed draw. return_ind_rate boolean indicates whether additional vector rate parameters used per observation used. alter structure results two lists, one storing tte name tte, name ind_rate return_df boolean indicates whether data.table object returned","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rpoisgamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process — rpoisgamma","text":"Estimate(s) time event based poisson/Poisson-Gamma (PG) Mixture/Negative Binomial (NB) distribution based given parameters","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rpoisgamma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process — rpoisgamma","text":"Function simulate event times Poisson Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process Event times determined sampling times events (TBEs) exponential distribution, cumulating derive event times. Events occurring within set observation time window retained returned. times Poisson process, provided rate assumed constant. PG NB, individual rates sampled Gamma distribution shape = theta scale = rate/theta.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/rpoisgamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process — rpoisgamma","text":"","code":"rpoisgamma(1,rate=1,obs_time=1,theta=1) #> [[1]] #> numeric(0) #>"},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Run the simulation — run_sim","title":"Run the simulation — run_sim","text":"Run simulation","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run the simulation — run_sim","text":"","code":"run_sim(   arm_list = c(\"int\", \"noint\"),   sensitivity_inputs = NULL,   common_all_inputs = NULL,   common_pt_inputs = NULL,   unique_pt_inputs = NULL,   init_event_list = NULL,   evt_react_list = evt_react_list,   util_ongoing_list = NULL,   util_instant_list = NULL,   util_cycle_list = NULL,   cost_ongoing_list = NULL,   cost_instant_list = NULL,   cost_cycle_list = NULL,   other_ongoing_list = NULL,   other_instant_list = NULL,   npats = 500,   n_sim = 1,   psa_bool = NULL,   sensitivity_bool = FALSE,   sensitivity_names = NULL,   n_sensitivity = 1,   input_out = NULL,   ipd = 1,   timed_freq = NULL,   debug = FALSE,   accum_backwards = FALSE,   continue_on_error = FALSE )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run the simulation — run_sim","text":"arm_list vector names interventions evaluated simulation sensitivity_inputs list sensitivity inputs change within sensitivity similar fashion common_all_inputs, etc common_all_inputs list inputs common across patients change within simulation common_pt_inputs list inputs change across patients affected intervention unique_pt_inputs list inputs change across intervention init_event_list list initial events event times. initial events given, \"Start\" event time 0 created automatically evt_react_list list event reactions util_ongoing_list Vector QALY named variables accrued ongoing basis (discounted using drq) util_instant_list Vector QALY named variables accrued instantaneously event (discounted using drq) util_cycle_list Vector QALY named variables accrued cycles (discounted using drq) cost_ongoing_list Vector cost named variables accrued ongoing basis (discounted using drc) cost_instant_list Vector cost named variables accrued instantaneously event (discounted using drc) cost_cycle_list Vector cost named variables accrued cycles (discounted using drc) other_ongoing_list Vector named variables accrued ongoing basis (discounted using drq) other_instant_list Vector named variables accrued instantaneously event (discounted using drq) npats number patients simulated (simulate npats * length(arm_list)) n_sim number simulations run per sensitivity psa_bool boolean determine PSA conducted. n_sim > 1 psa_bool = FALSE, differences simulations due sampling sensitivity_bool boolean determine Scenarios/DSA conducted. sensitivity_names vector scenario/DSA names can used select right sensitivity (e.g., c(\"Scenario_1\", \"Scenario_2\")). parameter \"sens_name_used\" created corresponds one used iteration. n_sensitivity Number sensitivity analysis (DSA Scenarios) run. interacted sensitivity_names argument null (n_sensitivityitivity = n_sensitivity * length(sensitivity_names)). DSA, many parameters . scenario, 1. input_out vector variables returned output data frame ipd Integer taking value 1 full IPD data returned, 2 IPD data aggregating events (returning last value numeric/character/factor variables. objects (e.g., matrices), IPD still returned aggregation rule clear). values mean IPD data returned (removes non-numerical length>1 items) timed_freq NULL, produce timed outputs. Otherwise number (e.g., every 1 year) debug TRUE, generate log file accum_backwards TRUE, ongoing accumulators count backwards (.e., current value applied previous update). FALSE, current value applied current event next time updated. continue_on_error TRUE, error patient stage attempt continue next simulation (works n_sim /n_sensitivity > 1, patient level)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run the simulation — run_sim","text":"list data frames simulation results","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run the simulation — run_sim","text":"function slightly different run_sim_parallel. run_sim_parallel runs multiple-core simulation level. run_sim uses -single core. run_sim can efficient using one simulation (e.g., deterministic), run_sim_parallel efficient number simulations >1 (e.g., PSA). Event ties processed order declared within init_event_list argument (evts argument within first sublist object). , program automatically adds sequence 0 (number events - 1) times 1e-10 add event times selecting event minimum time. time selected relatively small yet small ignored .min (see .Machine details) list protected objects used user input names  global environment avoid risk overwriting follows: c(\"arm\", \"arm_list\", \"categories_for_export\", \"cur_evtlist\", \"curtime\", \"evt\", \"\", \"prevtime\", \"sens\", \"simulation\", \"sens_name_used\",\"list_env\",\"uc_lists\",\"npats\",\"ipd\"). engine uses L'Ecuyer-CMRG random number generator. Note random seeds set unique category (.e., patient level, patient-arm level, etc.) drc `drq parameters passed within input lists, assigned value 0.03. Ongoing items look backward last time updated performing discounting accumulation. means user necessarily need keep updating value, add value changes looking forward (e.g., o_q = utility event 1, event 2 utility change, event 3 , want make sure add o_q = utility event 3 updating utility. program automatically look back event 1). Note previous versions package backward default, now switched forward. important note QALYs Costs (ongoing instant per cycle) used length 1. length > 1, model expand data, instead event row, event N rows (equal length costs/qalys discount passed). means processing results data needed order provide correct results. cycle lists used, expected user declare well name variable pasted cycle_l cycle_starttime (e.g., c_default_cycle_l c_default_cycle_starttime) ensure discounting can computed using cycles, cycle_l cycle length, cycle_starttime starting time variable started counting. `debug = TRUE“ export log file timestamp error continue_on_error works inputs loaded patient level (patient arm-patient) inputs loaded simulation sensitivity level, considered error stages likely due severe issues patient sampling issues","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run the simulation — run_sim","text":"","code":"if (FALSE) { # \\dontrun{ run_sim(arm_list=c(\"int\",\"noint\"), common_all_inputs = common_all_inputs, common_pt_inputs = common_pt_inputs, unique_pt_inputs = unique_pt_inputs, init_event_list = init_event_list, evt_react_list = evt_react_list, util_ongoing_list = util_ongoing_list, util_instant_list = util_instant_list, cost_ongoing_list = cost_ongoing_list, cost_instant_list = cost_instant_list, other_ongoing_list = other_ongoing_list, npats = 500, n_sim = 1, psa_bool = FALSE, ipd = 1) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim_parallel.html","id":null,"dir":"Reference","previous_headings":"","what":"Run simulations in parallel mode (at the simulation level) — run_sim_parallel","title":"Run simulations in parallel mode (at the simulation level) — run_sim_parallel","text":"Run simulations parallel mode (simulation level)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim_parallel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run simulations in parallel mode (at the simulation level) — run_sim_parallel","text":"","code":"run_sim_parallel(   arm_list = c(\"int\", \"noint\"),   sensitivity_inputs = NULL,   common_all_inputs = NULL,   common_pt_inputs = NULL,   unique_pt_inputs = NULL,   init_event_list = NULL,   evt_react_list = evt_react_list,   util_ongoing_list = NULL,   util_instant_list = NULL,   util_cycle_list = NULL,   cost_ongoing_list = NULL,   cost_instant_list = NULL,   cost_cycle_list = NULL,   other_ongoing_list = NULL,   other_instant_list = NULL,   npats = 500,   n_sim = 1,   psa_bool = NULL,   sensitivity_bool = FALSE,   sensitivity_names = NULL,   n_sensitivity = 1,   ncores = 1,   input_out = NULL,   ipd = 1,   timed_freq = NULL,   debug = FALSE,   accum_backwards = FALSE,   continue_on_error = FALSE )"},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim_parallel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run simulations in parallel mode (at the simulation level) — run_sim_parallel","text":"arm_list vector names interventions evaluated simulation sensitivity_inputs list sensitivity inputs change within sensitivity similar fashion common_all_inputs, etc common_all_inputs list inputs common across patients change within simulation common_pt_inputs list inputs change across patients affected intervention unique_pt_inputs list inputs change across intervention init_event_list list initial events event times. initial events given, \"Start\" event time 0 created automatically evt_react_list list event reactions util_ongoing_list Vector QALY named variables accrued ongoing basis (discounted using drq) util_instant_list Vector QALY named variables accrued instantaneously event (discounted using drq) util_cycle_list Vector QALY named variables accrued cycles (discounted using drq) cost_ongoing_list Vector cost named variables accrued ongoing basis (discounted using drc) cost_instant_list Vector cost named variables accrued instantaneously event (discounted using drc) cost_cycle_list Vector cost named variables accrued cycles (discounted using drc) other_ongoing_list Vector named variables accrued ongoing basis (discounted using drq) other_instant_list Vector named variables accrued instantaneously event (discounted using drq) npats number patients simulated (simulate npats * length(arm_list)) n_sim number simulations run per sensitivity psa_bool boolean determine PSA conducted. n_sim > 1 psa_bool = FALSE, differences simulations due sampling sensitivity_bool boolean determine Scenarios/DSA conducted. sensitivity_names vector scenario/DSA names can used select right sensitivity (e.g., c(\"Scenario_1\", \"Scenario_2\")). parameter \"sens_name_used\" created corresponds one used iteration. n_sensitivity Number sensitivity analysis (DSA Scenarios) run. interacted sensitivity_names argument null (n_sensitivityitivity = n_sensitivity * length(sensitivity_names)). DSA, many parameters . scenario, 1. ncores number cores use parallel computing input_out vector variables returned output data frame ipd Integer taking value 0 IPD data returned, 1 full IPD data returned, 2 IPD data aggregating events timed_freq NULL, produce timed outputs. Otherwise number (e.g., every 1 year) debug TRUE, generate log file accum_backwards TRUE, ongoing accumulators count backwards (.e., current value applied previous update). FALSE, current value applied current event next time updated. continue_on_error TRUE, error  patient stage attempt continue next simulation (works n_sim /n_sensitivity > 1, patient level)","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim_parallel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run simulations in parallel mode (at the simulation level) — run_sim_parallel","text":"list lists analysis results","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim_parallel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run simulations in parallel mode (at the simulation level) — run_sim_parallel","text":"function slightly different run_sim. run_sim allows run single-core. run_sim_parallel allows use multiple-core simulation level, making efficient large number simulations relative run_sim (e.g.,  PSA). Event ties processed order declared within init_event_list argument (evts argument within first sublist object). , program automatically adds sequence 0 (number events - 1) times 1e-10 add event times selecting event minimum time. time selected relatively small yet small ignored .min (see .Machine details) list protected objects used user input names global environment avoid risk overwriting follows: c(\"arm\", \"arm_list\", \"categories_for_export\", \"cur_evtlist\", \"curtime\", \"evt\", \"\", \"prevtime\", \"sens\", \"simulation\", \"sens_name_used\",\"list_env\",\"uc_lists\",\"npats\",\"ipd\"). engine uses L'Ecuyer-CMRG random number generator. Note ncores > 1, results per simulation exactly replicable using run_sim_parallel (seeds automatically transformed seven integer seeds -.e, L'Ecuyer-CMRG seeds-) drc drq parameters passed within input lists, assigned value 0.03. Note random seeds set unique category (.e., patient level, patient-arm level, etc.) Ongoing items look backward last time updated performing discounting accumulation. means user necessarily need keep updating value, add value changes looking forward (e.g., o_q = utility event 1, event 2 utility change, event 3 , want make sure add o_q = utility event 3 updating utility. program automatically look back event 1). Note previous versions package backward default, now switched forward. cycle lists used, expected user declare well name variable pasted cycle_l cycle_starttime (e.g., c_default_cycle_l c_default_cycle_starttime) ensure discounting can computed using cycles, cycle_l cycle length, cycle_starttime starting time variable started counting. `debug = TRUE“ export log file timestamp error continue_on_error works inputs loaded patient level (patient arm-patient) inputs loaded simulation sensitivity level, considered error stages likely due severe issues patient sampling issues","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/run_sim_parallel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run simulations in parallel mode (at the simulation level) — run_sim_parallel","text":"","code":"if (FALSE) { # \\dontrun{ run_sim_parallel(arm_list=c(\"int\",\"noint\"), common_all_inputs = common_all_inputs, common_pt_inputs = common_pt_inputs, unique_pt_inputs = unique_pt_inputs, init_event_list = init_event_list, evt_react_list = evt_react_list, util_ongoing_list = util_ongoing_list, util_instant_list = util_instant_list, cost_ongoing_list = cost_ongoing_list, cost_instant_list = cost_instant_list, npats = 500, n_sim = 1, psa_bool = FALSE, ncores = future::availableCores(), ipd = 1) } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/runif_stream.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a random uniform 0-1 for a given random seed substream and updates the value — runif_stream","title":"Creates a random uniform 0-1 for a given random seed substream and updates the value — runif_stream","text":"Creates random uniform 0-1 given random seed substream updates value","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/runif_stream.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a random uniform 0-1 for a given random seed substream and updates the value — runif_stream","text":"","code":"runif_stream(n = 1, random_seed, gen = \"event_seq\")"},{"path":"https://jsanchezalv.github.io/RDICE/reference/runif_stream.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a random uniform 0-1 for a given random seed substream and updates the value — runif_stream","text":"n Number elements random_seed Substream used gen Context function applied. Can values \"event\" (reaction event), \"add_item\" (used within add_item unique_pt_inputs argument run_sim), \"initialize\" (used within \"add_tte\" function), \"event\" used modify_item, \"event_seq\" (assumed default, need declared explicitly) modify_item_seq","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/runif_stream.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a random uniform 0-1 for a given random seed substream and updates the value — runif_stream","text":"vector uniform values 0 1","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/runif_stream.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a random uniform 0-1 for a given random seed substream and updates the value — runif_stream","text":"","code":"if (FALSE) { # \\dontrun{ x <- .Random.seed runif_stream(n=1, x, gen=\"event\") } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_det.html","id":null,"dir":"Reference","previous_headings":"","what":"Deterministic results for a specific treatment — summary_results_det","title":"Deterministic results for a specific treatment — summary_results_det","text":"Deterministic results specific treatment","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_det.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deterministic results for a specific treatment — summary_results_det","text":"","code":"summary_results_det(out = results[[1]][[1]], arm = NULL, wtp = 50000)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_det.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deterministic results for a specific treatment — summary_results_det","text":"final_output data frame list object returned run_sim() arm reference treatment calculation incremental outcomes wtp Willingness pay INMB","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_det.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deterministic results for a specific treatment — summary_results_det","text":"dataframe absolute costs, LYs, QALYs, ICER ICUR intervention","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_det.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deterministic results for a specific treatment — summary_results_det","text":"","code":"if (FALSE) { # \\dontrun{ summary_results_det(results[[1]][[1]],arm=\"int\") } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sens.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of sensitivity outputs for a treatment — summary_results_sens","title":"Summary of sensitivity outputs for a treatment — summary_results_sens","text":"Summary sensitivity outputs treatment","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of sensitivity outputs for a treatment — summary_results_sens","text":"","code":"summary_results_sens(out = results, arm = NULL, wtp = 50000)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of sensitivity outputs for a treatment — summary_results_sens","text":"list object returned run_sim() arm reference treatment calculation incremental outcomes wtp Willingness pay INMB","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of sensitivity outputs for a treatment — summary_results_sens","text":"data frame sensitivity output per arm","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of sensitivity outputs for a treatment — summary_results_sens","text":"","code":"if (FALSE) { # \\dontrun{ summary_results_sens(results, arm=\"int\") } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sim.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of PSA outputs for a treatment — summary_results_sim","title":"Summary of PSA outputs for a treatment — summary_results_sim","text":"Summary PSA outputs treatment","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary of PSA outputs for a treatment — summary_results_sim","text":"","code":"summary_results_sim(out = results[[1]], arm = NULL, wtp = 50000)"},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of PSA outputs for a treatment — summary_results_sim","text":"output_sim data frame list object returned run_sim() arm reference treatment calculation incremental outcomes wtp Willingness pay INMB","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary of PSA outputs for a treatment — summary_results_sim","text":"data frame mean 95% CI absolute costs, LYs, QALYs, ICER ICUR intervention PSA samples","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/summary_results_sim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of PSA outputs for a treatment — summary_results_sim","text":"","code":"if (FALSE) { # \\dontrun{ summary_results_sim(results[[1]], arm=\"int\") } # }"},{"path":"https://jsanchezalv.github.io/RDICE/reference/tte.df.html","id":null,"dir":"Reference","previous_headings":"","what":"Example TTE IPD data — tte.df","title":"Example TTE IPD data — tte.df","text":"example TTE IPD data example_ipd file","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/tte.df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example TTE IPD data — tte.df","text":"","code":"tte.df"},{"path":[]},{"path":"https://jsanchezalv.github.io/RDICE/reference/tte.df.html","id":"tte-df","dir":"Reference","previous_headings":"","what":"tte.df","title":"Example TTE IPD data — tte.df","text":"data frame 1000 rows 8 columns: USUBJID Patient ID ARMCD, ARM Arm code variables PARAMCD, PARAM Parameter AVAL, AVALCD Values interest CNSR Censored observation?","code":""},{"path":"https://jsanchezalv.github.io/RDICE/reference/tte.df.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example TTE IPD data — tte.df","text":"Simulated FlexsurvPlus package using sim_adtte(seed = 821, rho = 0, beta_1a = log(0.6), beta_1b = log(0.6), beta_pd = log(0.2))","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-097","dir":"Changelog","previous_headings":"","what":"RDICE 0.97","title":"RDICE 0.97","text":"Update based validation comments Gabriel ** Modified conditional quantile functions weibull llogistic better match default R stats behavior Set License GPL >=3","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-096","dir":"Changelog","previous_headings":"","what":"RDICE 0.96","title":"RDICE 0.96","text":"Update based validation comments Gabriel. Renamed conditional quantile functions consistency.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-095","dir":"Changelog","previous_headings":"","what":"RDICE 0.95","title":"RDICE 0.95","text":"Seeds used default changed guarantee uniqueness Added possibility continuing next simulation error (occurs patient/arm level, statics/structural loading level) Debug mode now exports log even simulation stops due error. combined continue error, continue export log timestamp","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-094","dir":"Changelog","previous_headings":"","what":"RDICE 0.94","title":"RDICE 0.94","text":"Added possibility accumulating outputs continuously backward forward using accum_backward option run_sim run_sim_parallel","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-093","dir":"Changelog","previous_headings":"","what":"RDICE 0.93","title":"RDICE 0.93","text":"Conditional quantile functions added adjusted Luck adjustment function added instructions user","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-092","dir":"Changelog","previous_headings":"","what":"RDICE 0.92","title":"RDICE 0.92","text":"Progress bar added parallel standard computing model use progress bar batch mode quarto document, make sure add knitr options knitr: opts_chunk: R.options: progressr.enable: true","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-091","dir":"Changelog","previous_headings":"","what":"RDICE 0.91","title":"RDICE 0.91","text":"Debug mode exports txt file","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-09","dir":"Changelog","previous_headings":"","what":"RDICE 0.9","title":"RDICE 0.9","text":"Warning, commit change previous results. Sensitivity-level simulaton-level seeds moved outside input loading loop caused correlation inputs loaded stages.","code":""},{"path":"https://jsanchezalv.github.io/RDICE/news/index.html","id":"rdice-05","dir":"Changelog","previous_headings":"","what":"RDICE 0.5","title":"RDICE 0.5","text":"Initial set-news file Summary inputs overhauled provide INMB WTP argument Summary now can also provided across analyses quickly obtain DSA/scenario analysis results summarized","code":""}]
